{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":2553108068005893267,"abi":{"parameters":[{"name":"move","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"},{"name":"commitment","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"2001280241088787747":{"error_kind":"string","string":"Calculated commitment does not match provided public commitment"},"9492748729204277542":{"error_kind":"string","string":"Invalid move: must be 0, 1, or 2"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"61":{"source":"// This circuit verifies that a given move and salt match a public commitment,\n// and that the move itself is valid (0, 1, or 2).\nfn main(move: u8, salt: Field, commitment: pub Field) {\n    // Constraint 1: The move must be valid (0 for Rock, 1 for Paper, 2 for Scissors)\n    assert((move == 0) | (move == 1) | (move == 2), \"Invalid move: must be 0, 1, or 2\");\n\n    // Constraint 2: The Poseidon hash of (salt, move) must match the public commitment\n    let calculated_commitment = std::hash::poseidon::bn254::hash_2([salt, move as Field]);\n    assert(calculated_commitment == commitment, \"Calculated commitment does not match provided public commitment\");\n}","path":"/home/eya/zkp-rps-game/noir_circuits/rps_logic/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert"]}