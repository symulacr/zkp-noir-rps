{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":7832225328601220506,"abi":{"parameters":[{"name":"move","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"5730046799540934507":{"error_kind":"string","string":"Invalid move provided for commitment generation"}}},"bytecode":"H4sIAAAAAAAA/+W9dbx2TXaW+XS60+m4ddzdk5JdVbtiQAMBAgQIECBo2QYGH9whuMMAg1vwwQd3iJAEdxncffDBYa51Ol/Y63TPX2vvmfP95rR87/e+533Orl1Va933tUpe83jz11e87vH47Ne8+dfyj9d+5T/l6w3873WP//Fnz79e+b2v/pX/dLYvf+FnufPzvvbOB37tDZ/7utNnRZe3bZWwfPTNhdr35LbU8+53n/Y0wx7j2re91F6Lq36Lyx+pxuMrP+yudr/u9IIv+lz3/9Vgs77j8/O+7Z0PLB/+Ns8+1/rwb3vhM77+VTBwX/9WPtf6rK9//P93EqzjzV/n5327Ox/47S6cBK88/Ntd+IxveLz8SfCGx3WT4JV3+IbrnvGtttv6LmViyUR97cXv83WPlxlA3/6F94eMl7d/K3PZ2b78hePQv/0Ln8uv+crPfIt36FfY97blvrZQ/d6jG92tMOOxRx7QuyN732pz3k3fV5thHsfafWhzurG/5sJ2v8Pps/za/OQ/xQ/fUzlq8GnO2UeIK5RRtraPkdxYcR8+RlcbT3P0I+y5jtXd4/R19bi5ss3vqJ7r8NuWQkxH8Ns+Ut1z2ovP9eAljLnvpbt9btO5Pe/zSLlmwunmasprz9sd40b65B0e18/pd3rcG3Oc7cv/P40d7/uxcnXH9LQmjrhS3Fz3jdY5X0L2+0puZZ/pnjzrdEdcxQc/61pltSvf4Tur+ZLKmm0OhoSfKbh9HNEfxR8tHgyqMV1pWw0jOpd3BtqeeHTnmTNTBtDjxvlyZZvf5fxczIEj8r1rb6NWvjEQp9LOO2+765VQVsJeouul9ZjH4lOPuFe3xlHike4YN9In73zDfHnXx73zxec1N8/T9V6HGzm35X3dwnZI0O2jRr8xuI7Z51otpZlH3tIW59iqi+spjr3TDe2Or7m33aFX13sj9A4ZOpVsV1aZg1m+h+XmUVxuPW9kmh620kslGcZethVziXnKeHzXG9q9XdzuV75ee/FzvtuFc+fCvvbn9xfcmnklol9dHZmQSqk78eAoM6y6jVgT8bm1upV9D6G00RKDPmamQvaxvbVx42xfXt7bu90wbt798bLzqjzfu9/Q7vd4vDrmy3uen/OodWZHJIn7HvuBtCvDLReIxK6Utbbdt4Iej6GUuSEHS/eFlN6Db4zT83wJW21rIANnqWGXb93CSDnW5dDxvvZY1pY9Mnrl7tqsqRY0yTEJazv6QM2XDXmT97G3Y5Q9Hrk3JoTfJ5OhuEJQDijOLdee8Ap51Zz34EL0Y7jU47pj3Mh7e88bxs0bHy97vsjzvfGGdr/X49UxX95bPecYOWz56D4e7djLqC4jrRGzTCKCd5FkTfTuK+fY8bI7lpV/xBFa7/M8X3CzqzM3Ejp5BVHD+Yg9h7XFmHpNSIISRDSGgT/GWI5ZK0N9C5JAQlDzBRWUvathDiSCT37ygxsz1cXBnOge/+piSiUdK8Y4czhm22ZoCZHV79Gh8t7e+4Zx8z6Plz1f5Pne54Z2v+/N7Wb49HJs2Mvm1jZqD53I346EDGmE/br1VQYkZoYtlh15Onn4VENvuwfbiJZ4jxvanW7W31bfITnhvW5od37hvkPm9vve0O5yk+943cXP+X7XzUd/4Rj3F44bf+4LkpBn0LfV22ptD3uLJU9yYDu2RrIbey/Qz9LmhmkJdV9HIf/J7+0p5PnWxqCzfXnpg/e7YQy+/+Nl5xh5vve/od0f8Hh1zL0PPD8nDiZH4rUraZK3jjF2l3HOc+7Q0bCFwGgNTaxDwx9kSg3Aa/nNbYfCqbln9EP5Qj+k5l7hs0vsYUhCchG9iWyL+6I2ATydwcUIqQ/o05hCHz6hBXfqI/Ooo5f9jjEoffCBN4zBD3q87Lknz/dBN7T7gx+vjrn3IafPCjiJ2o+2bYzb0fbJ2MO4lIpo9NtBja4yf7rr+4608AH5iNNhAoUQUt713DN6q3yht1JzL25rUL5oTHnqfmFR+es0NDS/ge7gelLAiDwiKqrM3Pm8uiKzOtGgGO4Yg9IHH3LDGPzQx8uee/J8H3pDuz/s5nZbvZVonA+4od37C/dWkl8++IZ21xfurWRuf9gN7f7UV4m3+vDr5qO/cIz7C8eNP/eFTz0FKePzupZHlR57DgO5dxT+m13r3hEJkmsxEi6GpKvjyFJORoaGW/Sd9MGH3zAGP+LxsnOMPN9H3NDuj3y8OubeRz2u81b7hd6qXuitVBycYz/azLOurcd0pDVrixSbMmFZVnctt/YmWjPtSNMwi8NzrTWOzG8e+Y4xKH3wUTeMwY9+vOy5J8/30Te0+2Mer46597GP67zVfqG3qhd6K5X3On+YjmMEzzwfLaOYiktMx3j0lMtq22Iu7wcf7481atldSn5vG/N71nHHGJQ++NgbxuDHPV723JPn+7gb2v3xN7fb6q1E43zkDe3+tBfurSS/fMwN7f70F+6tZG5//A3t/oxXibf6hOvmo79wjPsLx43/DJWv4OKIwF6CH20eq66D7NmplB0jMkWoYjVJV6nslQDhy+DF7dPlOldK9a2NQWf78tIHn3DDGPzEx8vOMfJ8n3hDuz/phbdb+vqTbmj3Jz/OnihuW8SJHXk7kI0eT1TWlD0Cx0Bc5bxj53p2pIvmS9jEVDkczliYmRUep6+3ffac1hz7yRe2+VPObT6OmhO+MaS+HWUdLu97n2Ld3HHgTrd5tFV4CrLhfhwenZzGFlvLI8U0z/EreJ6KItoQOzoxvK50YH+o/Ig5JYFkJ9lz9zOQbvziz6gNTJSy6ysd5/jlQ9kxoHhisbbBLQp0DnW7ENu0eCzXY480e1/Dj+4Sr5cPcntFpa8ZVfyqvdXC114C0hwtTYkhkt9cLmmDA0l9gh83EMx83hxY3iiSu/eIILiFDUkffMoN49k9XvY8lg91N7Tbv/B2S1/7G9odznM5tAOr24+ZZlmgpomNJSsPZmOENzHAe1sZMTumYwa7rRN4PF6xMQ/8V+2Xkq/XP2+/X0zno+dE0Y7456Osum9BYlMfBDMipovJT7e5bcYcSsswnlKizzNu6Ry/rLEwXPj+4vm5Zkf4rgJ7y5W477eE119xUrPcMfegKhq2bxPXIBuytp3qJILYpzB2EJmKhSij2Ao6iehVW66ggUW0g/u1vW8+JYqgLh+tyLbNOEb1ffbYBt8ZZk9KyzXEl9+n7HGo9KjLELR9rTrExKdxVELZvif44Tr4nn3ESjcsLA1uZW9KVx+D93TQrljykL8UG3/3AIqEYzng+cqh4wh6hp7wOH4rhe8lSdT9qOWOuSF9EG+YG9vjZccEeb7thnanF95u6et0Q7vzeS5vR5+xHI2JmdfGXCh7C27WOBABbiAtCoO+9A1YHkOkYAQLhAcKAGDqPE5fb/fsOXHLziMmmGsOq0NIrQnjjMxIPW5EVM/EK8DuNhETI5a0gI5bS9XPSWQ5x0JrXD3HQmtczRf2RTm3kaxUt+IaKYlSBAmJNwhCIY4SsmKndrfvAMyUxGcmfqoPk9C00oouOaUxPRW+yHuNs9d9wGkIZJQ5EgQWzlopfCTUptRTFsGa4OgO2QYP6XQo0KTj6pYalKfJd6Lm/TzAo22gKdG3/GzIBwy3uwBidVRj6iJyUsmpe8vEbq0xw35Q3UxtyZ+QTcnFcxzk3FDX7gLFFuQzKcCXg2xx0NUo5CVgNvHfW9Z2Sh+UG+bZ/njZ8UWeb7+h3fWFt1v6ut7Q7k99nOvsrYZKbGLKSr19btTYq5hjgiyxZ5fwOaTmcPApC4d8tFaoyHemRg5qj/obnrd/LzGl2OsWjxqOXnzG9cnSMOoeqCK8aUOiySoyPxJYlo9HZS1ETq9teqUxjTH6HFetMVrlJWOM/tQL+/XT1Lv3JWHG2z74kxADYWmnGygtFXzDjrXeGikUSsxHU9GmoaGvjjjkQ3NXMdq1bUILU4aKuL3XnsEnZNV80HiULkUuxkyBp0iZDO9PcGY00aMhVadiNOWx5RvYUTgML7seybexh6M0nwnZtRK/Y41tkUQij0Z9vYcqx2/kRvVMad9RoRfkGwaVPwAMfNTcatkmo7keR6wU9/a80fpFAinjoIsYaa3RO9PdwjGlDz7thjn76Y+XHavk+T79hnZ/xgtvt/T1Z9zQ7s98nL1nmQsdFDD9jcEbgkfhri7lnANPt8eFTwxrT/xEguc2AlyPiZcxqNTIH6evt3/2nMgcaOF0fFQthxC0QMno6DuyDFlHWJYFJMA8P0vpNUMBF7UyiEPdDr8Ub7XGe6V9jfH+HKOt8V7lS2O8/8wLx8hXO7cRmhGEgYYwa6dziHsSmGWZw5HanDXIN8AaCKwEZ6kB1b4NQvdqfSuqbkUdqM6dVpbD5xqdxGSi9oHgLSsVGTME77XIMcdGmC09H/AMidKQ9qi4r5xlhYI/YkzRg3JpEBUmBtcBpF2REuXhDwQ16SS53Ft0MGFJMoUO7ZvS5BAu6poFnl8m1d04Ej0V4r4FOAdjGCbm9z2P6KXUeYzgyG9MFvg1HPiWPfDSB1/thvn/1R8vO+698nxXt/trvPB2S19/jRva/abzMxJKKFyFJgsHd+ose4s+8bfHhizCeRK68iGVnkX8QYWjk6j1bAUPmkYoj9PXOzx7zhCRQXHjU8HKx5wJoBK2o/pKBWZvfXp+uAvE1RxdgKoQPjJlFTltbsY9qPqaMXcoTW7MHUqTG3PHOd5bc8c53ltzx5suHG9f8/xcjDRqfIRLXk+Ox0HrOr+TpeqwvHMtkUzG4EHpIukP7GKuIHSprIWgec52pEJBMNJE/r9iKelZKQq2WRqdQeUPV0Ldrxf6Mx50en+zSB/UaFXuIIiP2A6YC9llBiocdZ+8/03Kf1gIKoh4iVAn1cljPEH93tcT+655ZZU7xl5nY4gnWA8yypXM6BVk09eeKQjLssGFbsqAcfk9Sqi15OL7Fka7Z8+S9MHXvCGWfK3Hy46h8nxf64Z2f+0X3m7p6699Q7s/66H8tSPaMhN2aKWnzi4Rk8Dut4YWg4JSHh8Q1YN/27PD7Y9Emhmyb2Il5RXe8Xn7i1jsLfki9a6ZQbF9+I3SGGG/JXz4FmQtUZSzFl2sY18oMUGtsj3DR5U7jHlI1UmNeUh5BWMeUl7BmIfOucOah865w5qHPuvCsft1zm2knkOK4V0Q+X1hYIhniNiD6d2UsuhG/McybIt0QAs67xJoJZUgEkHXHubwQqjmRqBn8DXZeArPpxxaSCip4l/4E2q5qfcSl+zPWI2Xv+WNf+2KWQ03DtIgLyJieSgyy8aIQ9YKYbYRZBVzDiClNhsL9d+GG6eOQeGD0sHqiln5zrdV6hlr8tSRSvDOhznKxjJvB09dXCwhyYpyjBeUaqYVhg95HhVS+3hcH5ekD77O4/q49HUfLzsey/N93Rva/fVeeLulr7/eDe3+7PMztpD3dezFlZjX0xGPVOv6glCgB1F/5JIqqWEbw8WxUoQrRNn0dBxU2bbH6eudnj2np2DYqTceVCUIu3AH9OQ4xsbk8x0KEmYrEux96CjXnZqjrAPxc+zovdYUszLmNJWHjDntnIesOU15GGNOUx7GmNOUzzXmtHMesua0z75wHnx99b727vs86HGxJLCtfY8tVCr9cvip93NtZWNa4GBIBS0ciY/p1DNyDqQnXYeZlFsCBbq5ZWrPmKN0DMZcSrLGaKN84nIeXXCYR+cJNh6L78syJEfX6zGXpJX4dHI5o/NgTvnJdHWTmg3Fc2kbj0GFfBwQQt5p4XVssi+357JUHaaKd+vSmh4ZyhSD0two9BfKTJO/SJOoM9GpjUlOF47ZPfUoBrjkU1k+cnmMkz74+o/rY9w3eLzs2C7P9w1uaPc3fOHtlr7+hje0+3POc5nkxH8IcZQ4twzqDpQrHQLVoye3PcDjiIX7qG6RInJFshEhvSwzJ5Wo9eTv/Ow5RV7uYLzZMlXWjYjhZ9tjPtCX+LOnldDkUvg+FdODPFVB5rJuhmIn9ETVYaz5UXE5Y35UOc2YH885zZoflbcy5kflrYz58ZzTrPnxsx/X5cfPuXBOfaNzP1JfOmbpg2ev6aA2tOdJQWrI/nk6hp9fQ6GSlYDhfY8kSyhiZypS2qJjVX6sPC/8g/Qir2GmmiLsEJsFpqT6hc5svCFG6KzUhagT5cR7lSmaCqxE5UcybfQDGyeLbvfI1GCu+DS2besb7hOOyA8LY3g+bg2KsORf/hWpG0Io5/wo639jKLTs4H3NUuH5zIMmZwUyXokkskWlJapWfVHpzTWPJppgOAZJuSVeSh98o8f18fIbP152npDn+8Y3tPubvPB2S19/kxva/bnnuVzWLqcqEzqJsG2vg7CWyYe9wFxi254OAmPyQSLJnBuB0FPEpRQcNirRKj++y/P2p+gEhIB7xuKD9z742G0SmmqUlRA5SbhEalLSJoW6wIyXkvUiq/APvV/BlmvVOgVjrlXs0ZhrVX405lq1/sSYa5XnM+Za5fmMuVbxCmOuVTrRmGs/98L5+U3Pz7Xx06Wstz+NHrfT4ZBQ/rU5X4/hnAyMfuSxM1pz3/kTHsllv4ovbahcS0LGuXomMxU5hsJO4e8IlA2P4pZvKcmJOKRdyKrs1Ov7U/XBhYOZu6Wicm0sOTYiQXA+HO3IBwVDF/gNwkXfqyNOoA3cSoSUGuRom1VoJlkV59m64qvHTAhwLDUemb+6p1TcsWfS/6JOKPc/MZcYerzIQht7WjR8y75k8u9xy/kZ0gff9HF97P1mj5edc+T5vtkN7f7mL7zd0tff/IZ2f975Gf0mMnJRra7HIo5Q3aDwPvMgUqYdtlrqIN5TNedTyHVBEgtGlIAJfa2P09e7PnvOwAShYBJ8AluRwlI/Cg/o5R41qhXV9W1vhNHWKSOG4xiyKHG4OkYqi9Cr+Koxb+v9MLa8rdaIGPO24qvGvK1yrTFvn3OtNW8rL2rM28qLGvP25zyuy9uf+7gub3/ehXP9W6jxNVaUpbzBMdAKk8nPWPrTDSeBKLBVEG3kyXHMtTtZIkkObpneCd6tQ+/pH3KmFW84Ul3NRz1aZ1B7pgqVSedKw4VujunErJedqSkzS5lS4OXI+P50fY4If8YLT3un0lnLUxjoG7qA0BRF+4+AhX7aC8Z7lcEvpzYyI2DEh1qf45Jscq6UfQ/et2zn9+vIjjGEH05tFIZRrpRotwrinnw0w1iKvq1kpu0tazulD77F4/o4/i0fLzt/yfN9yxva/a1eeLulr7/VDe3+/MfZIw/XNn9so5O3KaQgk7cpE1yu8TrIjCQQcmSIFEsP7/a5mu8dqiRxrrXH6evdnj2nl8MBmNauCjfrUKWNeQxGYtJXJrecl08FdvLARU7uoPpD/nZZNl8OApxan2PUAIohGzWA3m9l0wBqfY5RAyiGbNQAKm8bNYBaD2bUAMojGzWA8shGDXDO21YN8HmP6zTA518YN771uR+DtIg5Rr+TiwOav1E7HgzxmIucEssM5VknT+JxvI1sis1vIPHoWix6jW6YQ67prkxy2TbXxmJ2r6cLxfkbMcpdaUvWDMreDDD0iLWu2J2nQu2G0gCMyqOWeYzO2/diQGB9cgqPXAawFmXusDOpPYmbKnEei6lfuxy1FBsQX3Fyep4RgMfvjjfUZL916BOQnxe1NoLCKA68DrGnuBw3Xgfqw8MTwtbWfsudbdIH3/pxfU74No+XnQvl+b7NDe3+ti+83dLX3/aGdn+7x5lRydZcgv/ODPOd+k8sIfIvAQCFdD+2Q8ZzQBI7RyWMwDOqp/DMpAy7Ox6nr3d/3v5VCFXE8F6aBMFKFgK1k3AjP0VCfEjb4EEXtP4glhWBbZMcTJnNHbqObNQTam2UUU8oTm7UE3o/n01PqLVRRj2hOLlRTygNYNQTZw1g1RPKuxv1hPLuRj2h2ZpNT3z+4zo98e0ujEHf/tyPTP+aea9e6gHh8Dul8L0kXvMmkpteSBKGRgmNjhS2KAdkHygHfl5R55x6mRHMEKp6sum/tkJql0MGKaHPUQc1hU6df+evZn4cr8sB5yWdQylcDGqtNU8gl3jxXlNnGvNzMUlxj5TcWwtrW4lxninfj8mfFKaULMgBBFAOYNLqs7GoRrRK7WJLVADikkoG06163lIpckoanyCn1cghQUinUggaQ87a32RiyGdcnV+kD7794/r88h0eLzuvyvN9hxva3V54u6Wv2w3t7ue5nA7kNuF8XzUQg0oneETfybXHMcMsspRTjoWrlOkIVMw8x78BGFbw+ek4k6/6eo9nz0lgms7PnGaT2l5NTF6iokQ9pMTcj/a04GZN/mC5KnvOM7aC0iLyfG9V1QKM2kTVAozaRK1LM2oTVQswahO9X9SmTc56wqpNVC3AqE2UnjBqk7OesGoTxRSM2kQxBaM2OesJqzZRPsSoTfqF8Wyod+8neID0ffD2c2WeMA2Y5U3YKQ+xHyU3qYYcC8bRGcJEN0xSRw6EcOgz2PPBY1D/PMjr1Bf64jmJJVIemQSK5ZkyKIyUGKGEnV06KUciwHEwSD5d6wmKGkwT1AE9KFu1mL8b4sbNzmumOsOL9mHliJKSc41zhVTANEaV85aUNulyfeKsNTGxXU4MnHxMX1t3h2fUUbadDMvGuHEdhJLS8GHfmXDEF96ofMbVuUr6YDyuz1Xz8bJztDzfvKHd64W3W/p63dDu43GOMfC5SCKti3jGRHFHbgP53hnVmb80o+C9IflvG7nkQOzeAsywVaKC0ibv+ew5fQpUL5NcuUUFkAjGb/jYw/REMObj6gQtfrb3joCdPXMSgFLIo3LdwabXBBp1jqp3GHWOqncYdY5aE2jUOareYdQ5SpsYdY5aE2jUOareYdQ5SpsYdY5aZ2vUOYp1GHWOYh1GnXPWJlad0x/X6ZxzPLPGxu94bmMjp8uLR1YcnkpLbJWu5QXxMvinHPrTmcmygnGGTCJt0fF9so9BtjaodR1hbMz5JPO/dNlQzht/WjJBxNj9iDhBxsxxyMG9+5it+eXdoIOJI2AVrXM2Ic3NtxaX1J0WLySGwCzexty3LdYkWxl3ZE89ZGHZBn05CEtzJ7Sp88nBNEmOaUlQmMq3FDkBRi5CLBS/maxjYzAURyyV2lDk8xvVnAgJ93Kc8y3nk0sffMfH9XnvOz1edr6X5/tON7T7O7/wdktff+cb2v0/Pc76AXlBpCUYMwlLlJPHo9xDQtG0lgR0oYq6p6dFzXyUXHIyhozzQqYbRemcNz5vfyyyyHqXGwhdzWiJGhdpdSM3JllcPZk1vkW5aXS4jWDJoxDigpy5V6Za12HVTIrBGDWTqukYNZOq6Rg1k1qPadRMqqZj1Ex6v7tNM6n1mEbNpGo6Rs2kdI5RM511jlUzKQZj1EyKwRg101nnWDWT9m02zXSOjdY4+13O/ZiPWFyLlHwYWymBrxlJiUYdlaHZeqOSLje5pgrEqbKc7kB35MONI+WRFBsaxMviNi833iFRfIcDjUawmI4P6bWvQAEepIPwavvxdAyPLIJh2FKRz/p+PvlZeNydelmmvESQWTjcxSczSFBvTS7A2g5+Qty2Wnmp6WlMVOE+XtetKoUp7+nw1NBXfCyD208/XGogrtWIfS2vvpXAp0c5rk6W72xlkAbqLWcESR98l8f1OfS7Pl62dpDn+643tPu7vfB2S19/txva/d3PzwiGPeSMLilgLYCnXE+aGM/7iDuV2twDGYmJSIIl8EhRmKRWnCQWokB/nL7e63n78STChLPsIF8gZB6kty6XMVUpI3cmE+0YNMHzoVS9iY1r5Igs2HJWmsmqv5RmMuovxYaM+kvVrYz6S9WtjPrrrJms+kvVrYz6S5+nYNNfai2sUX+pupVRfynNZNRfat27UX8pNmTUX4oNGfXXWTNZ9Zfyk0b9dY6z1pj9Pc5tFECz90V5KzF2ZBdiXwclriIrZ0L0kCLiQqXjDl7CSNLrxz7kdaZQ1XlWlL0o7xE+NsFRjVE4I+E1+LYzH5gkiRGLYpITqkSeJn5FeUwKa5VprtchI9T6qtPLoVfMtS2FzYfg5eqQ1bHc20YSASntmQHT42Kejv1YhywPKjFrZpWJX7RkY4K0TY6h3JhHbgoXYzoz7nkSepY5KxujaTLazu2TkbbPdctZwdIH3+NxfT7+no+XrUPk+b7nDe3+Xi+83dLX3+uGdv/Pj7MWIdiiDcbYCfXtYAQTymVRHZEXf0PKR1swU+QSzacLdZJokxx7lHyp9hC/97PnJCusvMmxdHBt4vOQ88PbQZDoxyB09X3Hs8QjMVGJf8zK3GVq9cz0JpbrPcQ2Ladqc0Ytp/SXUcspZmXUcqo2Z9RyqjZn1HJqHbJRy6nanFHL6fM6bFpOrUM2ajlVmzNqOaW/jFrurL+sWk4xK6OWU8zKqOXO+suq5b774zotd47Z1vj/vc9tRNLEjL8+XCoVVHX4sPVCfPdTFi8RRahMEn+eAmGsFCukZLdRUzw8rvzZPZ57hWjRmA2VtQiL1EDW3p62joXg5h69D0dOO9GEeiE0jbrfKInhV3rQWk7uHmK2diomhEpmsEOR7QckbHkJrcTqTl9OBCd1lwm3k3E03BxyhLfScvSYa3LGKoGnMD4Tmi0Ttnm1pLNZ5IY85rUrvKvWQig5U5alwglp27Zb1llJH3zvx/W5/fs8Xramkef7Pje0+/u+8HZLX3/fG9r9/R5nvSWnIqBgxiJgRSbskivBFtFZrk5xbsepuUUaRfHtKIdSJREyl8gCbarztt/n2XOSfDJq8IhHb2nK4UuSniUT1Z1UEZxcCrPLhT51Hx5Ht0uwPAKS6JBzUtW+cqMu1PvKbbpQ1R+NulDfqWrThYqlGXWhqj8adaGqPxp1oVoDbtSFqv5o1IX6PBibLlRrwI26UNUfjbpQaTmjLjxrOasuVCzNqAsVSzPqQlWzMOpC5b+NuvAc/6255Pur+PW0BB7NRRyIEV1HLRKyld0+5HQ+14ZcBZ2XvEC5gpSx2ASA8SOzc5rxydW820bYq09H9/BWGLpAN8qfe6Y4WugLPj5mXsNBRNkX79Enhldnou1qb6Dc3ksecDsDuofBg/BdhFoC/0Z5lpDEI4ASo8jCoyw6oMohpLPxV6Zef5/yogtzCotC6qpHCcWPdexBVvCE6mSMbzSu5Y3sAxsBXu5hJD9CzvfcHSx98P0f1+uEH/B42fpInu8H3NDuH/jC2y19/QNvaPcPOj9jIvN0yHeWy49A9/zdTjJuyTFh922TW7uJnEefk+9gZhL1156JjmSG7B+nr/d99pz4I1TUsfHZVAASjB7ZMYuoJlm/X6pLkn7J42QwJMbaJGx5j0rEqvmk16XZNKY6a8CoMfVZAzaNqWqsRo2pdKFRYyrGZ9SYqsZq1JiqxmrUmGr9vVFjqhqrUWPq84ZsGlOtvzdqTFVjNWpMpQuNGvOsC60aUzE+o8ZUjM+oMc+60Koxv9/jOo15ziXWvPSDH7r2xBBMCb5IXXiORffJpUBMJZF/AWRIiWmPdUZ+4DpKd554RxhAnPmsNOYiybht4499SMT3VT1xNMv7dXIvQxppZJcjcSG3bS25TK97xGwGglR1FrUjFJS4zxTDAQKkPxkEEE8GPlKTNCCnYsT1tNeUMQzGdHxQhIfGQTocSmO2OvcZJvVkB6lEqWam+fCtVX4xSu8kyd4Jx51p62kDgUR26RMdmUi3nGclffCDH9drjh/yeNlaS57vh9zQ7h/6wtstff1Db2j3DzvPZQGPsPfiGjrtIHmREkKSFXwrLCJzJajzYQsGD1KPe2bWzc6/8Ds5pcfp6/2ePafPVS6zjVjO0nmIST6OaJwptz8zt5YcZzsRR1MOhdsQGkzKPe8HIZYJrs+0NOpVvY7PplfV+RNGvarPn7DpVVVHNupVpTGNelWxR6NeVXVko15VdWSjXlV7H4x6VdWRjXpVn2dl06tq74NRr6o6slGvKo1p1KtnjWnVq4o9GvWqYo9GvXrWmFa9+oMe1+nVc16y5rgffu7HAv+jX+QMA2ptNLIecullJ854X0Iag1eIoCMA0q/AlJ05u/dN9mkcRZ+/Wr07GOpHOZ6K4shTfkkkzB2dOuVKpDJp+iH7BwXSADEjTyk3lzBq9JkkhbkfZRetc42ARxh1QkH3DTEZiV28P+YpY762WuQUd5Qn7wXQKXdoq3vK3E4f78MNOfQthE7JvjKnineEet6O30hS9c0XisJIZd74cTDtuicp7DIdL9cv0gc//HG9fvkRj5et2+T5fsQN7f6RL7zd0tc/8oZ2f8Hps/xOdkuEkpKYouPp5oGD6sNODs0HhYHjwGwGpse+jYN4zE9G9zhC+DGqrpW///P2EwsHsZ1kI6thEokryWWGkvupLjC3iMotEtlHLcTsRXGkbEwvxF9Pc+nzV23aVzFRo/bV6x5t2ledSWLUvvpMEpv2VbVyo/ZVetWofRUTNWpfVSs3al9VKzdqX7XvxKh9Va3cqH31eWk27XvWq1btq2rlRu2r9KpR+571qlX7KiZq1L6KiRq1r6qvGbWv4ihG7XvOcdZ8+aPUZ4XcPNOuHXPPNIY0yIhcQ+4NOAJpUjbR+DVDh/qE1XqksM+QqPkYUF7FakvemHSZ8ElqK/s+Fq850N2Mjn1Qo5QJQOs8Nb0hB9RENLEn7pCxU2hK+8pJYX4QhAPjffngYUyFGY/eJhr0XYI6cYaBvktkI1pAXRlxNKMDm9W9gSHyJldfsorUM72R8I3/uVnlMiRmDKmJmilz42CuodfHagxX/jnlbjX5jKu1kPTBj3pcr4V+9HXPeIsGlOf70Te0+8e88HZLX/+YG9r9Y0+fFZgShNHsE/YTZYkwYMoOOZJma2i0o1GMkAsySXHHJsu2mYkk4X3Jupy2P05fH/C8/XufctLNIiUSwseSQ6vkxIQq8Z3HW4MZng+UXd43uRAsOaYRlRRqK4hTtefHqKP1WcE2Ha1YrVFH63WiNh2tzqkx6milfY06Wq0HMOpopX2NOlqxWqOOVusBjDparQcw6mi158eoo9V6AKOOVtrXqKPVnh+jjlbrAYw6Wmlfo44+a1+rjlas1qijFas16uiz9rXqaMV3jDr6nC+tuffHnfuxHcuLmoSXMno2Jzde75NPZDwmuTJz0BNjIzL1QFglYywHcWYC5Dirvsezw67izKTrScIex8ZL36aTieMl4kgadz4zAQlKmTfBOM75YCyRvlZU+60IEoOARVqZPjAt3eYLuoCulWs9DuYlUdrJEtgYDmgZSW50FD8zN/pwKB0N1h6JsYzklvRPAqcTxvKQY4nQ2yAZM3qrBHCA+YqpRV7rIPAk324571H64Mc9rtdVP/66Z7xFT8rz/fgb2v0TXni7pa9/wg3t/onnuTwlpRJcAokqQo7xoHL2A/Z2QxiFvEfiFFlpH3sVgYNknHnJaiT0xFEep68PfPacOOqYV0Opke4I8mNuqEPqOiIW5XowJ4loZbQ0hR1PpiOXR0LXEYocAqZ0tFGTq/1WRk2uz7W2aXLFkI2aXK+rtWnys462anJ9dpFNk6s1D0ZNrnS0UZMrhmzU5GrNg1GTqzUPRk2u9lsZNbla82DU5Pq8R5smV/utjJpcrXkwanKlo42aXO23NWpyxZCNmlwxZKMmP+toqyb/sY/rNPk591rz+E86Pxfj+aBzF0FvyC11Vd7eAidHxnWpTyuUo4RZIhkh0nlHlh2DN0NciVOt61ie7mVQMW6WnPFJ5G9Qcj6iMWBB3Z32zlwmAM4Rawm+TFReanUDNa32uiG9mYiVwAVvXwwqQvuxMcznIhAw652MWAgdUSYg0FeJO0FoODl1q6p7dX2HsW9gerIMAZWZzzwjQheHIgkbSoAxNeXyv8qndQKZy3IXHvMyM1Ru0eTSBz/pcb1G+8nXPeMt2lSe7yff0O6f8sLbLX39U25o9099nP11j4TgJSuPNxK+XHo30eS+tny4no7OZ4iEQ6zOg0Dpglypu/KRqDHV+Dh9fdCz5yTwFspLTEfcOyo+pVVFZ6KzMroVb9uJ/5GSGCmq9EzGJQSQ0YiponbUOmSjvlea3Kjv1V43o77XZ7Db9L1i20Z9f9bkVn2vzrMy6nt9npVN36t1HUZ9rzS5Ud8rtm3U92pdh1Hfq3UdRn1/1uRWfa/WdRj1vT5P1Kbv1V43o75X6zqM+l5pcqO+P2tyq75XbNuo7xXbNur7sya36vuf+LhO35/zuFUT/LTzc42QGZdZ8uwmS54ZBoPcERDmDDp6ArzN6Ec9y31HBLQpqz2OlaZ349kdS7XmxdCMzLc2Qexpj2QypvW2uVLb6m4FOfAstxDJ4SRIiYMdGhga/aD3Gc7RXCJDM7Q2NDdT89gTCoW5jswPUU6grby92SLJmsTWGL6wRboW+aLWbZM7ySlk2jXjcTTJ7vS39zTwKKExUOTQjZ08UAuMPZPPeKYpPXWkLFcfXq73pA9+2uN6vffTr3vGW3SuPN9Pv6HdP+OFt1v6+mfc0O7/5TyXRavPrcuFFzXKGjKCFrNlR9AhoQnFA6HQx0zIQrK8HH0mfP5olMmSPq/2g5+3/80Xzx/8B+k1UAt7fyqHid3O4AC5ST4fstPC+Y7edVsj1VFlk8u0gz7LwugV1Lpto1dQ+t7oFdQ+Q6NX0PcF2LyCYu5Gr6DXbdu8gjrjzOgV9BlnNq+g1q4YvYLS90avoJi70SuotStGr6DWrhi9gtpnaPQKau2K0Svo82ptXkHtMzR6BbV2xegVlL43eoWzvrd6BcXcjV5BMXejVzjre6tX+KmP67zCWRNY9cXPVGNiQ2PHQnydKW28tdxza1XGIe1lxsTkUOkzpjoJXYTO3U0SE1Eb7O/0vfPHHnjLEkQ82ZNeksPqEBVEY8n3jCG5yUguAwPwM6qhk6URWtDl/DxVCyAcy+l5SPaNByC+b/K2liRZP+mtsWNooutAfLcV1AuDjxTE6KV/QlS1gLz10occwOzlTNjRIt84FrlekjURGcEUJBaK0PJureI3Hx1gda5U5brwy7Wj9MHPfFyvHX/Wdc94i2aW5/tZN7T7Z7/wdktf/+wb2v2/Ps7r0Cp2oRE/SUt9l+O8K9JqJRKUpBcEcsIIZyR4Z5o2iWSo/XiQzVAtyit8yLPnZOIEKno7D+hbCgRm4oELDdAw1/JrNuR1GLL5pZJ7wow4FRdDIlYQtPXdYkbfoda5G32HWudu9B3KKxh9h9rjafQdqhZg9B2qFmD0HXqdu813qHPvjL5Dn3tn8x1qfY7RdyivYPQdqhZg9B1qfY7Rd6j1OUbfofZ4Gn2HWp9j9B36PGSb71B7PI2+Q63PMfoO5RWMvuPsFay+Q9UCjL5D1QKMvuPsFay+Q/FDo+846wurVvk5536kZ6goSOhkWB1brLxjOXpwl+ULhSpDquSP1eckTWYRKjkHRPskc5Hile/gRdciS4/kwhMnx2LLWdl9EOgPCco7sYigi0tIiarCRP0DS0mSRKno1J16ZH3e8CH5qfGjEm8vrOwoZkig2CWiEni2PaBxus9O8GyKyAZGIOZD768lA0wkC3+B/mO6tUACr0Pu5SMLY2yQJV20ROYBeXgSbSQZT8onaeRb7tSTPvg5j+t16M+97hlv0d/yfD/3hnb/vBfebunrn3dDu3/+Q+lA4kUi9KFdCapopELE6pt3RD1C347V7iGLxvEdilDIrp0/44e1tvXH6etDnz2nR963gPySPeeeQBznwTzeSWioP0QcOfaQS4uIz2jZvTH9SyLZHmIefFU1CqOHUWuQjB5G7Qswehi1L8DoYZTvMHqYs++wehh9D4vNw3z24zoPo/cF2DyMOgvR6GH0WYg2D6PWIBk9jPIdRg+jahRGD6PWIBk9jFqDZPQwan+t0cOoNUhGD6PP27Z5GLW/1uhh1Boko4dRvsPoYdR5FEYPo2oURg+jahRGD3P2HVYPo7im0cOctYpV9/yCcz8ysxMFCB6Bv1iJAWTXXfYLj7zJCmsGLuPkIG4n7wqyBwy7k9oIsIS1qddZReKnHMdHYF28fAZjYigkIrFPEnBJnYlODHQ3uqMGPou0FRvTorisaic58g74eT07H0RNdFTPRq6UI+KJ18SXbSRsDa/Rydtk+FRCJ73NW1PnY/oqeijHOVEbnUAWuyvxKAdT8ZDX09vMRHrCHAM1MCF7hzujT3ou9Z59FNIHv+Bxvab9hdc94y1aXp7vF97Q7l/0wtstff2Lbmj3Lz4/I+oikEk7OgWRvfhFD3JSUCR+Z7kZFgG3i/1gtHuHlicJkH77oEaYn7YVftXXhz1v/8Z3UfAU+XjUeWwo8SY2JuOHUEydSg1MonZRz3JWkZMDwYIURgfWZ9d3Btn8kKqdGP2QWmdl9ENqH4XRD6l9FEY/pDyM0Q+pvc1GP6TvDLL5IVU7MfohvY/C5ofU+ZhGP6TPx7T5IbXOyuiHlIcx+iFVOzH6IbXOyuiH1Dorox9Se5uNfkitszL6IX2eu80Pqb3NRj909jBWP6Q8jNEPqXNFjH5I1U6MfkjVTox+6OxhrH7o5z+u80Nn3WPVUL/k/Fw75RoSy/DMmUYuxQVhKNBRiAuiu5giFBA/rG6ZHEcsYFgk+pAM6KNaS0bubFlOiiJUh224JmebMkopCs3FCG7kA8YnkiWRkiYEmgeduz8QBQWRpvwQn7GQYAzJXW4DyLysvaIJFgNV6kWJXExfM7swNuspLZJBiQMoGfi18kMIEiarxL8iW9uDnBiZExokj42MxN/kh6HEAvKLsLyYhhV1xQDn1YVb1pJJH/ySx/X6+Jde94y3+AJ5vl96Q7t/2Qtvt/T1L7uh3V94fkaSZskwDYnF4SB+E483IAWpYRskcfRo6nJFBkCD4Jl3+YYDCeEcUEKd9fThz56ToBcJEBtF2tWwIFkui8sdLZlJlkl003EgdwjJu2wAK7KDqyKbKO6SXKZaS2b0Vvp+K5u3UjUdo7dSa8mM3krtOzF6q7Mfsnor5YeM3krtKzd6K32/lc1bqZqO0VvpfSc2b6XOTDV6K31mqs1bnf2Q1VspP2T0VqqmY/RWai2Z0VuptWRGb6X2lRu9lb6P2+at9H0BNm919kNWb6XWkhm9lfJDRm+lzocxeitV0zF6K1XTMXqrsx+yeqtf/LjOW501lFWP/fJzGwmeDPLaD1q5iL3kWZwHcqGhgNba6c3EJGDe4G0ES9OZOxk6yNK6qM/RZXxWZs3c3EEvt51kFGmnlJmYmKRc99S/i6wrv3KryjK2NJiyK8xNnaNbchMN0ySxEvWbXPSGiULuNF5zPQ4eeZeTeonkcVAtC4FaE7NYymBBeSuSIPN0SMek/BR/opzvVVo/iJtMTGnkIp8U5JNs5OGFYC0DYmW2Op/2L1yttaUPfvnjeq39K657xls8hjzfr7ih3b/yhbdb+vpX3tDuX3V+RswI85IcjSQ6ZNb2USIOgnHNRCKNRUkbeQVyfkQhLYfOwdcgdfh5ap/ORzx7Ti8n9JIFiYZhJ79CKWTRau/V45NSPdCapWawBbI/Vh8qSRbrgKoi5xzqLjarT1Pr5Yw+Td/FZvNpqtZk9GlqvZzRp529ldWnqX06Rp+mvJXRp6k9/Uafpu9is/k0VWsy+jS9T8fm09Q5ukafpryV0aep9XJGn6a8ldGnqVqT0aep9XJGn6bWyxl9mtrTb/Rpar2c0acpb2X0aWpPv9GnqfVyRp+mvJXRp529ldWnqVqT0aepWpPRp+k1Njaf9oWP63zaWY9Ztd2vPrfRMXopKlXSdiVfrLBP6dgNr7a5fUQKWIUMTpDtc9KFWKMxmKKb3Fcdh6qBlTb6RlBrrsyJaiJE74FW8o4D+S4T57eSV5V7SxB3KdEZFLrIWWSbFT5d3/UXg99DIYON3CQMS+iJEoQICBujBLtIyOD15BEZ/5S5aMg2UItN35mNEiwYL+pbxDpm6yA6MHnbQVWvrBGZJ2gk1MsokwRDmY15zpAhoSzpXvmMq3W79MGvflyv23/Ndc94i1+R5/s1N7T7177wdktf/9ob2v2/Pc55Wu7GJn+jKmdi0uJr/BSbQO459ka4CZ3MS/AkLpLhqHsxmbyoT8KX8mkf+ew5KSHz7Z5quNydgkIkae1CeCiilbHvYfeRuEGy2wkYRF8gzkKTkXULfkTdd2L1fOrsNaPnU2sCjZ5P3xto83yqBmb0fGefZvV8al+T0fOpfU1Gz6d8mtHzqfMUjJ5P3xto83yqBmb0fHpfk83znX2a1fPps5Vtnk+tCTR6PuXTjJ5P1cCMnk+tCTR6PrUm0Oj51HkKRs/3BY/rPJ++78Tm+dR5CkbPp9YEGj2f8mlGz3f2aVbPp2pgRs+namBGz3f2aVbP96se13m+s7az6sRfd25jJq6T6gsVrxKLo32TwbAiEnFQGGsInypXYPa4M613glJu+KV97E+3tquzLIIIrq3tzjF9dl+IGdT6yBFJlAEjKBD8yXQ5yZEYvChGEH3MtGK2zqI8395DPhAZDlmxyLNEp8hAWhLTavQTc8pQk09L3pOWRFzRzp1ZgFZRZ1m4WWsj2jFTciPnHISBelCFo4DBk8UhBvIYThK6xIeWqCvua2PQMYn9LesepQ9+3eN6D/Drr3vGW7yPPN+vv6Hdv+GFt1v6+jfc0O7fePqscGTXydEL1ePRvD6OCATxE5UFW3HU31FLXfJIiJg0OWTbgXiIOHLNlXucvj7qeft5BoId2h/xhlMj8JPG847rCAcWAw00eKYkJ9jIOuoSHL8fcWz4QGaXqs0Z/aNa92j0j+oMPaN/VOsejf5R33Fp84+qNmf0j2rdo9E/qn1gRv+o9oEZ/aPyfEb/qM6yMPpHfcelzT+q2pzRP/bHdf5Rnbdt9I/6vG2bf1TrHo3+UXk+o39UtTmjf1TrHo3+Ua17NPrHs+ez+ke17tHoH/V9Ojb/qM6yMPpHte7R6B+V5zP6R3XultE/qtqc0T+q2pzRP6q1Ukb/qHi+0T+edaJVc/6m83NV4iAPslol8dfBXyaqH8k15jE9Jb/Hq6LCQIQlh08sJj2OFKMUOJo+g51gn5iyVcTciMRoT9jM1OSY5n603MhfcXRyE2OCuT88wYfw3OXJw1T+0aHTdlQuZcMsZyHyz9S2JxGZeDqsp1zVypij3unDigTmjCJiBiGgS1U1w02UFHniiB4BiDR0wfdcFsMzEwuyNKonXmii0nkQGHcCEYMDyUHUH/IZV/sJ6YPf9LjeT/zm657xFh8lz/ebb2j3b3nh7Za+/i03tPt/P8/lfcrJPEgI1A3urYj7QX/sqHEkMiltdIwDE5j5jc2rk9nZ5RBUKon853H6+uhnz4k3zShlOTdxBbIRNgjgRF4uHhTjZ5KTdwhmvjQsyuJnbQ01hhbAWcxdn8Fu9KKqZmj0omptp9GLqrMQjV5Ure00elHlH41eVNUMjV5Ure00elG1b87oRdW+OaMXVf7R6EXVOSJGL6rvY7V5UVUzNHpRvW/O5kXVGexGL6rPYLd5UbW20+hFlX80elFVMzR6UbW20+hFv+BxnRdV54gYvaha22n0ovq+JpsXVeeIGL2oWttp9KLKPxq96Nk/Wr2oqhkavaiqGRq96Nk/Wr3ob3xc50XPmtOqX3/r+bnkTPvAFMST+oOCJd25qHscSAD+cmQGUTlMZF/GDJVMpu+iFzcER2+xTn0uvycU+jLRCzQikkeYwUnKmQiNzHzfDy+3mBZmLvHBkSipsYQDc3js9VBetBHisJ1+SXTqhyTwkH1qYieZ9rTcbzIkNrokjJ4kIhGmJ0Pn4Nn03cH1IPDKSTVh9X3rdPg2aVlfsrvwIPsMPjyjHD022+OhV6ApA6dKrLpl/ar0wW99XO9Nftt1z3iLJ5Pn+203tPu3v/B2S1//9hva/TvOz7ihDsmn+SAHYOt2Qi/JnnzsMBywph2vKCbjYLpHickeiVcodx7U75+23H3V18c8bz/pf3f1mFLibzuRGp2c3Y6eZ2LzvM4jlGoI/KxM6sR15ZbQsxJCiCmqlmn0tWqfodHXqlqm0deq9atGX6vOtDT62jc9rvO1+u5gm69VtUyjr1XrV42+Vu0zNPpatc/Q6GuVFzX6WnWGi9HXqlqm0deqWqbR1+p9hjZfq87lN/pafS6/zdeq9atGX6u8qNHXqlqm0deevajV16r1q0Zfq85wMfpatX7V6Gv1fWA2X6vOcDH6WrV+1ehrlRc1+tqzF7X6WlXLNPpaVcs0+tqzF7X6WlX/MPras361auHfeX6ugFRqbfMOEZSymzvmUYouiaF+1C0PshnRWB6LAdIyugwbvDmRkMRdfVeD2zPdxsynWyIqIEzkw4GbzQe6gm4hSCwSMAaSORqY5E9no5LYCY/qbFL/5mu1aQyDcUM+yQcTMOpETna58440vvvChyOrS0gE2sKcjkFeydD7MnMLwY09EEt30sGitfFp5SKxNhW5ibuMOZBvIzQCYY9j1M1Tb2XQ93vW6Eof/M7H9T7nd133jLf4O3m+33VDu3/3C2+39PXvvqHdv+f8jGQ+JFSKaNmamLrE+Mzw3nyJQe50xiEQ6rNUVDNICU0aCFoOnTP7sasa68c+e86A3EZJJMfc429gongeLANJbk+ENE/22uQiSgBZIfEgesWo8qAi+7I+m9TokVWN1eiR1b5Mo0dWNVajR1ZrdI0e+exrrR5ZrdE1emR9z7XNI6saq9EjqzW6Ro+s9mUaPbLal2n0yMrXGj3y2ddaPbK+59rmkVWN1eiR9b5Mm0dWdzUYPbK+q8HmkdUaXaNHVr7W6JFVjdXokdUaXaNHVmt0jR5ZnZ9j9Mhqja7RI+v75mweWZ2fY/TIao2u0SMrX2v0yGdfa/XIqsZq9Miqxmr0yGdfa/XIv+NxnUc+a2Grrv69am4TcGTJ72Lq+DDQITseuCFdJ5l5Sr7hn8ju2WiC4+kXgrsy1iYzzKvaL6PZSQosqaYn2dUW5SZGaW+VlhH7EVID5zlIIQjnKofQNvqZtLZvTt3fUciATCzSR+dNOZH8syLIG1pgya5Vv2JtjcwS6Tf8Op46MVPkaFxep7q/o1PaSrztWGTv7CIiNrnLo/DbgQIZeQkT31AdwckljDI/0tYIXW0HE+zyGVd7JumD3/u43jP9vuue8RavKM/3+25o9+9/4e2Wvv79N7T7D6hn7A3hhKfBK3uRlgQUdBy6ociZyfHwh1jmQTDdkImM+SRL8BORnwm0PU5fH/fsOT22FU8cZBkGprvPxdzulbxc5VrElNA/yB4CIj+d8jOG5Kj1KaOIp3Cq9mv026r2a/TbqvZr9NtqH6vRb6var9Fvnz2y1W+rM2aNflutQzb6bX0nu81vq9qv0W+rdchGv632sRr9ttrHavTbyiMb/bY6u8jot/Wd7Da/rWq/Rr+t97Ha/La6v8Pot/X9HTa/rdYhG/228shGv61qv0a/rdYhG/22Wods9Nvq7CKj31brkI1+W99naPPb6uwio98+e2Sr31Ye2ei3zx7Z6rdV7dfot1Xt1+i31dpFo9/+PY/r/PZZV1s1+h88t3GKeI4iHHug0ByoHo+D0Sg7fzGuxCJEJ9qXMbikd+kK7ygyI7Co4Tblt7ecBq9682Pb+pH3gV1vBA3S/0ZTKkGXBBQL8YqxIc/uiRdB5NlO55/9tsj2iOJmpJNQp2c2R1DAzmuaJaWtkuECBXKSYaFSXUS5oF02UfpIK+23UWy8aiIYEc9XeagVqWbT1N6Qbr2LFakke6ryZSAxfaRfQ0i9MQyf1qBe7b+kD/7g43r/9Yeue8ZbfKc83x+6od1/+IW3W/r6D9/Q7i86PyNKEqVHHEYlELzJaXUnR3qc55JDsZkYIcPNckwHQZipNN2UVShBXPj+OH19/PP2k6YOmbt+7hvamdwISCvZj+gktYlKjzvsC5RFExwOsES5eXYQtfGn6qxgo3dXNWmjd1c1aaN3VzVpo3dX+36N3l3VpI3eXa21Nnp3dVaw0burtdZG7678ttG7q5q00burtdZG7672/Rq9+9lvW7278ttG767OjTJ6d1WTNnp3VZM2ene979fm3dWdLkbvru90sXn3s9+2enflt43eXdWkjd5drbU2ene11tro3dW5UUbvrtZaG727vi/T5t3Pftvq3dVaa6N3V37b6N3V+aJG765q0kbvrmrSRu+u1mcavfsfeFzn3c8a3ar3v/jcxgOJ5nLIpDaZesR9MekMVkZr5LeZYlsiw6K18OSRP+/MKJL5kWLNRd3zI6owEQ+2g0CaMAVbWwh8niCjy52c8uyrPBBqNsR9C3KEUN8ZGEX+iqqVVyYoWihGAigKxa0a8AGpiqCjY+JexCk4NDRjM0dCzcaPPpDshKeW1Hpyhn1HHG8B+4G0IazwnbPKaUY+kESYNEcIfuPRlhiQjLAlICBS5JjrIp9xtZeTPvjix/Ve7kuue8ZbPKw835fc0O4vfeHtlr7+0hva/UceZw0eE4pftDbJBzmI7lt4N4+JxbXvuXfi/QprbmJ1KaVHMu4xS28yS9U9P5/wvP0oUjcr+S7Ktcgo08y8JC3jhgm1ZDQ5CJ4klCaZ0Y3F/+BrWMvRiBuqVm7lAOrMZyMHULVyIwdQtXIjB1C1ciMHOHt3KwdQtXIjB1DryY0cQJ35bOQAaj25kQMo727kAKpWbuQAaj25kQP0x3UcQO2TNnIA5d2NHECd2WXkAKpWbuQAqlZu5AB6n7SNA6h7fowcQHl3IwdQ68mNHEB5dyMHULVyIwdQ68mNHECtJzdyAHVml5EDqPXkRg6gvLuRA6gzu4wcQK0nN3IA5d2NHODs3a0cQNXKjRxA1cqNHECtQTVygC96XMcBznrf6h2+7NyPpHheuSem1swk5/l9L2WmQyJGyHLvkpeKPG3CmNO4FbaZyMn0ve9L7SsvSDiq/3JvEzV7ERYJUR1QBaR5Oa0MhedxESLeV0WqVFIdcoAESdBIqoYf5qiLeEzAZcbIIuBcG+V/hNfOYKezNrkJOIlKRzyvHEgOdeaFCspxV+el+cX0YXzylRGQxTsCBLqGHzEQsSgong8iEHwou6wOIKogVchNkUgsMudyXyh98GWP633hl1/3jLf4YXm+L7+h3V/xwtstff0VN7T7j54+C2NKKmxx7iMGWQ6fM6mLEIXrWLJQvm0E7dpI1gcaD95HBX+R3FYAsiV199MnPntOjxNHsstqmDIHVi8QL4hnlTkzSPSl9VHxpJCFRHhHAmBwBt69zdxxuHpfuY0pqDXzRqagzu42MgVVwzcyBVXDNzIFVcM3MgW1r9zIFFQN38gU1Jp5I1NQZ3cbmYJaM29kCooDGJmCquEbmcKZA1iZgtpXbmQKal+5kSkoDmBkCuq8NCNTUDV8I1NQNXwjU9D7ym1M4cwBrExB3/1kYwpqzbyRKSgOYGQKqoZvZApqzbyRKag180amoM5LMzKFL3xcxxT0fb82pqDOSzMyBbVm3sgUFAcwMoUzB7AyBVXDNzIFVcM3MoUzB7AyBVX3MzKFs3ew+pA/ptooy+rbTh/RVmY+Yr50sg56ro2GANodQemQY5oZwk0OdVtNojCDkPii9gW4FpF3/A8Pf4gKWPQrMVhimRccQHhfklZ5CGYWpp1BB7nw2AY6V51VFyLJfMobosP5q7usZEY5R/yP7wz0Ij7DE1PDwXtA6KS2ocYCI5+goNYWEMkRJXTWLh4L0etSIOUz/heCpyeED/pO1lfQwfux5YhcYsjKVgG6Vj7jao8pffDHHtd7zD9+3TPe4q3l+f74De3+Ey+83dLXf+KGdv/J8zPOmiIGnMzkkPwyykGDjeDK0EbuMHsqDoAJg1uuT3m6by41Ejp/R5/B/knPnjPg4oTYDYmufB6ZP/CoTPI9HMIHV8MjxYomy3LcI1lx7AFzPuQGhKTOqrPyCb0P38Yn1L4AI59QZ7Ab+YRaW2DkE2ptgZFPqLUFRj6h9uEb+YRaW2DkE2pfgJFPqDPYjXxC7Qsw8gnFFIx8Qq0tMPIJtS/AyCfUPnwjn1D78I18QjEFI59QZ9UZ+YRaW2DkE2ptgZFPfMHjOj6h7gMz8gl9H5iNT6h9AUY+oZiCkU+otQVGPqH2BRj5hNoXYOQTZ6Zg5RNqX4CRT+j7pG18Qp1VZ+QTal+AkU8opmDkE2emYOUTam2BkU+otQVGPnFmClY+oeqRRj5x9iFWT/Onzs+FFRhOLm2bpIbiyNprQ6XxslJjnqxaupxX33ZiPIqaYJ1JESPR/kaSVHsfZiMeHHv1qD3vyG+bpLmKY9iJE9vBC5iR0N9QVHQRY0RG96qkG1KVviPOFaKtHOlPdCe7tlwjsXGXW+AQbO7YiSMBD3TIhgbPeyX8OglBiMTu07M1D4l3RERJchl7CTOQXomEXeY4o6vjWiraBGXlDmwCMQ5BEXjtu+QX+Yyr/ar0wZ96XO9X//R1z3iLT5fn+9M3tPvPvPB2S1//mRva/WcfZ4ZwMI/XwEOXmqboy82RG8nzhU8lTGcCFvmbJEvIQky5xSRzcgJIYc4+Tl+f/Ow5A4mlkmOYIwsFGVAkc/ONaCviFRuFGcaVtEGMJX53nhsTLwduMnF9buqcQCPrUHsfjKxDn1tgYx1q74ORdaiz9I2sQ615MLIOtebByDrUmgcj61DnFhhZh1rzYGQdau+DkXWos/SNrEPtfTCyDsUnjKxDrXkwsg6198HIOtS5BUbWoc4tMLIOxSeMrEOdE2hkHWrNg5F1qDUPRtahzy2wsQ51R5yRdeg74mysQ+19MLIOxSeMrEOteTCyDrX3wcg6vvBxHetQ5wQaWYfa+2BkHfq+chvrUOcEGlmH2vtgZB2KTxhZx5lPWFmHWvNgZB1qzYORdZz5hJV1/MnHdazj7Gms/ujPnftxw+/kueeUZWE4jmeSTfzaRORtNaFByBFoIFnpcPhOHCEMyXGI9DrNeXYnwh7C4Qjvi3mLCqDrWtz5lezg6PggRN0cRGn6kTfeRUgxhcJAvzSvznkYhF8E1b4QqjsuhJec8QlwCSb1DHL7GXoJ0UPGbkj1RCjbmd14j1zyptZi8G5xPejVSEbmk2RTOwMiNKJW2ORO8MTHYKhKDh5/MOWKCDppd8TX/HSf2tXeV/rgzz2u975//rpnvMXzy/P9+Rva/RdeeLulr//CDe3+i+dn3PxO+I9E00NWH22NCRzw0hvOc/iwQt4mf7SRCkc8MEVgyCoZFilOQnmcvj7lLZ7TIcWJoREtKhgybsiGNJEnG7kJBUEKwo83MACeCsOAsJhyTQkhsTm1v8PKTdQZjUZuovZ3GLmJPufBxk3U/g4jNzmzDis3UWsxjNxErcUwchO1FsPITdQ5D0ZuotZiGLmJ2t9h5CbqTgQjN+mP67iJYh1GbqLWYhi5idrfYeQm6pwHIzdR5zwYuYliHUZuos5oNHITtRbDyE3UWgwjN9HnPNi4ibo30MhN9L2BNm6i9ncYuYliHUZuotZiGLnJmXVYuYna32HkJuqMRiM3Ufs7jNxEsQ4jN1FnNBq5idrfYeQminUYucmZdVi5iVqLYeQmai2GkZuoNeFGbvJnH9dxk7M/snqtv6TGF3kOmbPJCZQkG3JpApEQ/ehgGhQYu2mTvJNnbq0egy5H2g6eOiAq1RoRUZ0tEDEd+Y8h2Jxj+hY8AiN393JGJtGGwCvNjnKdI3YMMwGRKVtX52J41AqKOcwtEeyhLY5suMvefqRmRfaKdNvRNc2X6vOCdxxkMxIMQY1Rq9aIRHqdeOgcUi6RwviUPNOgMt7oOxrs3SFmKvFgOe/0SkOADTk5NCLY5DOu9tHSB3/pcb2P/svXPeMt/ECe7y/f0O6/8sLbLX39V25o9/9x+iw5bUbOntlEdW/CKwm1UMIg+1VwVHL0TdtQxMzBQm6CgxJ4B/EUAfxmy/JVX+4t2o9oZG6HtRckCHF4l+NyxsE0hS2Sl7DKUzbBDfQlHrjIlrNG2MdFrXV88uM6BqO4iZHBqPMxjQxG7WExMhh9LoaNwZy5iZXBqLstjAxGrRExMhi1RsTIYNQaESODUediGBmMWiNiZDBqD4uRwZy5iZXBqD0sRgajuImRwag1IkYGo/awGBmMOhfDyGDUuRhGBqO4iZHBnLmJlcGoNSJGBqPWiBgZjD4Xw8Zg1F2SRgaj75K0MRi1h8XIYBQ3MTIYtUbEyGDUHhYjg1F7WIwMRp2PaWQwag+LkcEobmJkMOp8TCODUXtYjAxGcRMjgzlzEyuDUWtEjAxGrRExMpgzN7EymL/4uI7BnL2W1bf9VTUm5EU37BhzUESEHPsxsQeYlI24mCTCN1QYGi7uMxEBeWQnKQiNsLpiMGmisQkRjJrFozueXUSuw1Z11AzKkiTLfBYagpnD/RE90awIyjBD1Pt0RMzVfoCAyBmjk5ETVmrnpyO6NvpfDMyGbkl1HKgFxj+2YuAEhPMoBhMQCJPAUBPaj29GnUyMC4q+86GkoyzKfjF2yCwdT8S8dhndxIx3TxLzck8uffBXH9d78r923TPewiLk+f7aDe3+6y+83dLXf/2Gdv+Nh/LqT7fwkGKTx0wRqiCb5FnCeW9zKwIRMGVy3DAOFOZBklhPIXViHtT9ov55+5Hz+EsmEYpcDjx1TM7ShHMgBUg5g9xIkiCAZ4QUjSBsb0gMpDbKY6mzSY08Jzyu4zmKwRh5jjqb1Mhz1D4dI8950+M6nqP26Rh5jrqjxMhz1NoVI89Ra1eMPEetXTHyHHWOiJHnqLUrRp5zZjBWnqPuKDHyHLVPx8hzFIMx8hy1dsXIc9Q+HSPPUeeIGHmOOkfEyHMUgzHyHHU2qZHnqLUrRp6j1q4YeY4+R8TGc9T9okaeo+8XtfEctU/HyHMUgzHyHLV2xchz1D4dI89R+3SMPEedTWrkOWqfjpHnKAZj5DnqbFIjzzkzGCvPUQzGyHPODMbKc9TaFSPPUWtXjDxHre038hxV7zbynLNvs3rAv3nux0IiImzyIY3pH/LIsgUJx4A09NAUZjwi6ODh2upuYgUS2mcFMV5IHX3XDGqo4a9IZ7x7BmkNG5EQD4Eg3BgGjvdD2qR1qNXEDyDHInTQnYfvmufAXWgLowl1i2hmrkTZXSFbm5w/DlHQeEUEQCpEcn6ByHFbjnKCS49T8Rz6uDN6GKJlK0cRMUG8w3VMGfW8yRJLnkjBQdd0LBedklFTfGalyfIZV/t76YO/+bje3/+t657xFq4hz/e3bmj3337h7Za+/ts3tPvvnD4L4U7GW5gw0qgnZT+d/irORFJVYOCT0IYIeCSDYwZuuJrecgWDYnzVnbPheft5ylD2JuoPfYS3wmtBUhcmEV2CiEZYN1qAymiEkFjJDnzwIUIYwKt4jpENqXNhjWwoP65jQ4rnGNmQOhfWyIbOPMfKhvS5KzY2pPYiGdmQumvGyIbUmhojG1JraoxsSK2pMbIhde6KkQ2deY6VDam9SEY2pO6aMbIhtRfJyIYUzzGyIbWmxsiG1F4kIxtS564Y2dCZ51jZkOI5RjakzoU1siG1psbIhtSaGiMb0ueu2NiQunPWyIb0nbM2NnTmOVY2pHiOkQ2pNTVGNqT2IhnZkNqLZGRD6lxYIxtSe5GMbEjxHCMbOvMcKxtSe5GMbEjxHCMbOvMcKxtSa2qMbEitqTGyoTPPsbKhv/G4jg2dPaDVT/5d1Y/Mwoii430sUqUX/Z0ZuC2jMEpJO0YNQxKcZE98BQbT8TYziQvLo/dbBVdLZibvEjAxCjkyoSISfsUDRUKKZeySWfiVIxxOyeAZEVNaw0Spc2qwjqVj4vh7NaVUSNyjZOKYLBMSTIQE2ekYOo7IF/rmWuu94HyfQqG+M0iyqfQc81ksKU9FhCp+84GRRNx2h+SQQ3JsEzfEsyMxiC0EEl6yfMbVrED64O8+rmcFf++6Z7yFkcjz/b0b2v33X3i7pa///g3t/gfnuRxQIhEFinzDfZISkO+4FSQgCrHhDJokD+ZHX2GfBZnuJmkJHYVzy+Nx+orP27+h955MVMf4Qmlr9U1sJ6kc+bYRzPgTkgbqgqm0EaAP4hg6EljgVlRsyMiZFBsyciZ1Jq+RM33q4zrOpNiQkTOd2ZCVM6n9VkbOpM+psXEmtd/KyJnUnUFGzqTW+hg5k1rrY+RMaq2PkTOd2ZCVM6m1PkbOpPZbGTmTujPIyJnUfisjZ1JsyMiZ1FofI2dS+62MnOnMhqycSZ1TY+RMig0ZOZM6k9fImdRaHyNnUmt9jJxJn1Nj40zqHmIjZ1JsyMiZ1H4rI2dSbMjImdRaHyNnUvutjJxJ7bcyciZ1Jq+RM6n9VkbOpNiQkTOpM3mNnEnttzJyJsWGjJxJ3TNi5ExqrY+RM6m1PkbOpPZoGDmTWh9g5ExnP2n1pv9QzcexDWLrsTMz0SODIbEIO4jxOZHTGAnmaqiiMqM4G0Y934enTAVd2xRn2vbQBvINU7tPwtOUKDSFYNGfM0XiAulQjEaUE5fzYFwjoLba6ctZzpzJgXxCrlhb3nDd0kGLKrOQaD83xsKO2uxOsheN80wabCOWVpZIBdF4ijP5GST/HTAo0Z8i0Ggd+R6dUyZ0rIk9posWmh0vAE9DRE6sCHo7J/mMq7mD9ME/fFzPHf7Rdc94C2+R5/tHN7T7H7/wdktf/+Mb2v1PznOZfMc3zw13TQJDVjmUhMQ3V/qIc8liQEnihLpSkA5bw09hZbCkPmvOtD17zhDE5MB2Jw4N51FclDPI8bGBh4mehCTbSbcC7yBe+x0LvqHNNuRGIsVpzmRjVoozGZmV4kxGZqXOQzYyq898XMesFGcyMit1HrKRWak9ZUZmpc/1sTErtafMyKzU3U9GZqXWIBmZlVqDZGRWZ85kZVbqXB8js1JrkIzMSu0pMzIrdfeTkVmpPWVGZqU4k5FZqTVIRmZ15kxWZqXO9TEyK3Wuj5FZKc5kZFbqPGQjs1JrkIzMSq1BMjIrfa6PjVmdOZOVWem7qW3MSu0pMzIrxZmMzEqtQTIyK7WnzMis1J4yI7NS5yEbmdUXPa5jVoozGZmVOg/ZyKzUnjIjs1KcyciszpzJyqzUGiQjs1JrkIzM6syZrMzqHzyuY1Znb2r1uf9UxUJEDg9MXqmVt98i038xiXo8mPY9u4SE6EE2wZE8UIK4XaboYLA23qC6wytJeGCUE+4xOIkBDvXJzA9HcNlRxG2VLPt19rRksKfeO97JoX89mUYxq1HJ+4kXixArRbQMcjD1xqudeWbGLXOIxJSLzPJjJ3H2ioANjSBX9zOz8oNnJRgjCpkyRPJtdDBc5q037DKiwUHf5iHjnPw/iR24NnIMsjVj6+QzrmYY0gf/9HE9w/hn1z3jLexGnu+f3dDuf/7C2y19/c9vaPf/efosHOFCMiyGdkJfNCdUKW04UDR0IjMMtHuAxVZQ7SHXmDvZbpq6kwWM6ZXjp5++0rPnZGIjOjY0tyRRHGCKVQBVnruIACgOMw8IhKPISXxOlWRHYpJz7EFo6g4vI//SzMrGvxSzMvIvxayM/EudRW3kX296XMe/FLMy8i91FrWRf6l9c0b+pc9BsvEvtW/OyL/UHV5G/qXWRhn5V39cx7/U2igj/1LnIBn5l1obZeRfat+ckX+pO7yM/EvtmzPyL8WsjPzrzKys/EvtmzPyL3UOkpF/qXOQjPxLMSsj/1JnURv5l1obZeRfam2UkX994eM6/qXuKzfyL31fuY1/qX1zRv6lmJWRf6m1UUb+pfbNGfmX2jdn5F9nZmXlX2rfnJF/KWZl5F/qLGoj/1L75oz8SzErI/86Mysr/1Jro4z868ysrPzrzKys/OufPK7jX2efa/XM/+L8XJIHZUlWzqgRH/EBMq7C4RnthOq2TQgYNlQUCqZhY+QvpBESB+WxNP/aGOJk4TwwZMAwkpjAKN8Y+MQfvDnpAjGN40ZkIiCItu5AV5EAJfUp/kU4PtAHpTXEU2PmjLR5xxwu/H9xvMbEAxxyqRTDFX+K0iHy8J0l0pH6HHDeVYphEHLdTPiqTiRruA5eTGE6yAFYvIQdoZswNzthtZGyUQCR+fh0PvLVPET64F88ruch//K6Z7yFA8nz/csb2v2vXni7pa//1Q3t/tfnZ1yy0HBCaKAMTGOEPJC3kM52zIVszAXbtHW0hGBEvlbEwCi9T8ecggk/Tl/52XPyQ4OoD2YakmNtyG+3eSIZQboTK7rwL1kIKWaLfIR+Czt+hN8for4V/zKyNHUXm5Glaf5lY2mKfxlZmuJfRpb2psd1LO2zHtexNMW/jCxNnQNuZGlqb6CRpelzo2wsTe0NNLI0dRebkaWd+ZeVpak1W0aWptZsGVmaOjfKyNLUmi0jS1N7A40sTd3FZmRpam+gkaUp/mVkaWrNlpGlqb2BRpamzo0ysjR1bpSRpSn+ZWRp6hxwI0tTa7aMLO3Mv6wsTZ8bZWNp6g57I0vTd9jbWJraG2hkaYp/GVmaWrNlZGlqb6CRpX3R4zqWps4BN7I0tTfQyNIU/zKyNHUOuJGlqb2BRpam+JeRpZ35l5WlnfmXlaWpNVtGlnbmX1aWptZ5GFna2TNb/fe/ObcRrU3+pzkNsbNtwq0WrCqgfnEKwyXMDeM4SJu2xut3bjCQyAGHjAm9liwynhosCyUQ0HqNSV7Ab2A6/oiMz5uvA0B2FEQL3GsGcsEijVY5JOvM0tC+Y2e+4Ib5kJUR9y7z7ZOsWQmQdAgptM+AuEFw80lgMVR78nKI/NLnbK2JwE9YiSZBhodx3U0GbPIE7n0ywSJhUchhpHNR/Yi/XjLyBKcenq4Xu5qtSB/8m8f1bOXfXveMtzAleb5/e0O7/90Lb7f09b+7od3/1+mzvDi7gEHAQNRSK/kC006aRz+jAfMhUx0HiQgBOYmRlWPpIFGVmTGdWktWnj0nMmtU0fS4J4FbKy5gBKp0bkgDvPDCpy+oSyHJMIUqLC9IRiMDkpf9maVZuZxiaUYup+7UM3I5zdJsXE6xNCOXUyzNyOXUGexGLvfZj+u4nGJpRi6nzmA3cjm1/9HI5fQ5WzYup/Y/GrncmaVZuZxaS2bkcmotmZHLqbVkRi6nztkycjm1lszI5dT+RyOXU3fqGbncFzyu43KKpRm5nFpLZuRyav+jkcupc7aMXE6ds2XkcoqlGbmcOoPdyOXOLM3K5dRaMiOX0+ds2bjcmaVZuZxiaUYup/Y/GrmcYmlGLqfWkhm53JmlWbmc2v9o5HLqDHYjl1P7H41cTrE0I5dTZ7AbuZza/2jkcoqlGbncmaVZuZxaS2bkcmotmZHLnVmalcv968d1XO7sv61e/t+fn2u6wrfTPI9lEzolJ4ANicskZhQSo8U3nx1SE5HBexiMBw+ukxQf9N2IvTfkAi8CRcuTkFs8052Axusibq3W3S5zCWOAatlkhyYjtuKhkFBbVWvc8CxhEor4MUgnIWeLaJxLJ0juvEGR5biEhizHg+NbIrFydrJomvgstccTT4bFIDPXTY46YzgyZInTo026n55H7kzHfFgLsIFrZEbxE8bCK6Yn6345p5E++PeP6znNf7juGW/hU/J8/+GGdv/HF95u6ev/eEO7/9P5GZEF5GZEOmJ2iNVfNfmOQcwdaVIFQmxEZCZLjbCPJos/gQWC0xBJ/nH62p895xNLezpakJwzRUxuoHcxsRWLQTarQvcIHPmAC3bcQfaYtuLBaeicpNa4GRlfeFzH+BSXMzI+dTeikfFpLmdjfIrLGRmf4nJGxqfOvzcyvs95XMf4FJczMj51/r2R8ak9nkbGp88lszG+/riO8am7EY2MT61xMzI+tcbNyPjUGjcj41PnkhkZn1rjZmR8ao+nkfGduZyV8ak9nkbGp7ickfGpNW5Gxqf2eBoZnzqXzMj41LlkRsanuJyR8Z25nJXxqTVuRsan1rgZGZ8+l8zG+M5czsr4FJczMj61x9PI+BSXMzK+M5ezMj61x9PI+NQeTyPjU+ffGxmf2uNpZHyKyxkZnzr/3sj41B5PI+NTXM7I+NR9akbGp9a4GRmfWuNmZHxqX5iR8al1MUbGd/byVi7wn8/9CLcjKcxNdrKWRLeuVYBku6STDRfbyen0BtRvI80wVsjMfjBLER7pqGrtHfHRdTIgT0I+wmsT2XlF3aNTC46MJMx0rSntYEA8ADoR34MyhySSCdQdl8yY2pA58DiQnkNzENhF2JMEZE55ubgAffEU1JgQ6Fl+2HTQjEDsVGvvOlEbdZAwcjsNhGsc+H+iPz5/28Qz8rIG2lWYSEyi9OUl8lIPqGCTz7ia+Ugf/OfH9cznv1z3jLewLnm+/3JDu//rC2+39PV/vaHd/+08lwl+svq17AGmXchjwXc+dyYcrEjJUYE7KJmGWUChytFuZDXMFR5721/Bek9f9dlzwtsjGRUztsW4y/GHTrJGqE9XeDieiCiJvMbTkuKZ7Ex+Iuch0BFvXt9i7Z2BF6q1d0ZemB/X8ULF+Iy8UN1xaeSFmvHZeKFifEZeqBifkRequweMvPBzH9fxQsX4jLxQ3T1g5IVqH6uRFyrGZ+SFah+rkReqOy6NvFCtvTPyQrX2zsgL1do7Iy9U57gZeaFae2fkhWfGZ+WF6o5LIy9U+1iNvFAxPiMvVGvvjLxQ7WM18kJ1jpuRF6pz3Iy8UDE+Iy9Udw8YeaFae2fkhWrtnZEX6nPcbLzwzPisvFAxPiMvVPtYjbxQMT4jL1Rr74y8UO1jNfJCtY/VyAvV3QNGXqj2sRp5oWJ8Rl6o7h4w8sIz47PyQsX4jLxQ3Ytn5IVq7Z2RF6q1d0ZeeGZ8Vl74nx7X8cIzF7Ayhv9+biOGblsoNd+YuD4SoGfKS+57qAeqdXQyMXgAOfek3Jto8wBBxHUyNorihcQU5MvOGyVYY9znk8ljajUQBbaWx4VirIkP30MkyBGdCeYt7QyKLao1gfWQFMMcXKhjWgAzzPOQe1ARz8hWrPDTdtrCfMRIR1GGRDqUa5bUrnihOD5QIGZ/g6D0IasgxctEVFFAxU662YnGx98PTBB2qcSJvGIw8cfyGVfzI+mD//64nh89XvOyudnTB77m+na/5oW3+6mvb2j326g7eaHziyTWCctE5OYchQAcNDF1iRLsSyLaIncw4RDOiaCUARG4DvLHepy+PvXZc4a6udqE35CYBzbKpacEe+Q1MQRBVhR7foAwNFlr2HEAsA5SqCOJB6fXBNrY41usCTSwR7Um0MgeP/VxHXtUvNDIHs+80MoeNS+0sUfFC43sUfFCI3tU9z4Y2ePnPa5jj4oXGtmjuvfByB7PvNDKHvW5dzb2qPbqGtmjuqvUyB7VmkAje1RrAo3sUa0JNLJHde6dkT2eeaGVPaq9ukb2qO4qNbJHtVfXyB4VLzSyR7Um0Mge1V5dI3tU594Z2eOZF1rZo+KFRvao7n0wske1JtDIHtWaQCN71Ofe2djjmRda2aPihUb2eOaFVvaoeKGRPao1gUb2qPbqGtmj2qtrZI/q3gcje1R7dY3sUfFCI3s880Ire1R7dY3sUfFCI3s880Ire1RrAo3sUa0JNLJHtb/PyB7/2+M69nhmDFZe8drzmsADF5qH7MWlw/eddyfhFd9JZzpxoZFMxLzGIckGYbxFTh4Zvzmm4+EUe5Rv6qJIaOCO5u372hCui1ZsOwEKdYrMqoAEjOlEEiBDIwMZC4DbWYo9YvtRS0uWE2EUEbXewTbkrg3vescUYYxJ6mhCTIeoD+mAKDcOTNlLrPYjk+xxYXQ8f0U2OeN8d1I4ZqjEgzhGo7b21JXkjknggXYOPCGhlTAt1upyFiV98NobWNTrXjiDk+d73Q3tftsX3m7p67e9od2vP4/z9cRAyDXEd1HWYQ4RlphZwhbzeaEBOngvClgnoQQ4Huo0ys5lPNDj9PVpz9vfstB/XAzztspBmnErKILU547dwFpj/mQKOeIWhsnNBlA85P+F9R2KPRo5pl6raOOYb7FW0cAx1VpFI8f8zMd1HFOxRyPHVHfOGjmmZo82jqnYo5FjKvZo5Jjqzg0jx/z8x3UcU7FHI8fsj+s4ptqPbOSY+pxAG8dU+5GNHFPdOWvkmGqtopFjqrWKRo6p1ioaOeaZPVo5plqraOSYaj+ykWOqO2eNHFPtRzZyTMUejRxTrVU0cky1H9nIMc/s0cox1TmBRo6p2KORY6o7N4wcU61VNHJMtVbRyDH1OYE2jnlmj1aOqdijkWOq/chGjqnYo5FjqrWKRo6p9iMbOabaj2zkmOrODSPHVPuRjRxTsUcjx1R3bhg5ptqPbOSYij0aOeaZPVo5plqraOSYaq2ikWOe2aOVY77Na67jmK+/kGO+3Zn5HLwNVBn8jzi9EU1AAJ7JhC4fE4yHAXBwCHoRzyDKmD/cYyAWYDAOfXfwHMWhVPkGOqj0lpvIVO+JU4eco0gwdrKR2xOsiJGpk3MDXISW79vm1H0nce4NL0o8mUy6A+ey+X0XK8X/SDXERckFh6SCcQBWRC4go0RwoAcUxyQIEwaD2BMfNmZRbjQG0oCARjARaDCOBEQGR0SZ47MWIXcRL5E59ZY1lNIHb3cD13rDC+d58nxvuKHdb//C2y19/fY3tPsd9B1BUnaYON6KHCQ3Q/qJ8VkGvANcoo3kMNMK8esR+oNpwawdyD1s0dORZl/19enPntOTXkmBC4oxAIc7UhQJA+BjLhIRhb8MlzyyHTNCdiI0ItiEYAKfIARnjmlloopjGpmoXkNpY6JvsYbSwETVGkojE33T4zomqjimkYmqu4ONTFRzTBsTVRzTyEQVxzQyUXXfiZGJfrvHdUxUcUwjE1X3nRiZqNpzbWSi+lxFGxNVe66NTFTdHWxkomoNpZGJqjWURiZ65phWJqrOVTQyUbWG0shE1Z5rIxNVdwcbmajac21koopjGpmoWkNpZKJnjmlloupcRSMTVecqGpmo4phGJqruOzEyUbWG0shE1RpKIxPV5yramOiZY1qZqOKYRiaq9lwbmajimEYmqtZQGpmo2nNtZKJqz7WRiar7ToxM9O88rmOiimMamai678TIRNWeayMTVRzTyETPHNPKRNUaSiMTVWsojUz0zDGtTPT1FzLRd7iQib7j+bmYgCR1uMVWUMxM7BFoqd/c08brHjsRRM6yKx0dzNs45KXUFTbiEelW3TVD941NUiBytWwFE7YhmSPWAFeJWCVoEdDokFZ5d8JIOxaUHEKiYbKocygFyx7j4C8mOVCPqYNo6nvA0EVC7nFATD3Oj5cOeVg1QVCYZgcegLk9PkPdWyNZAx1QMHtRFCC2B3GFBQz8YKLhAdjAwFfkf0Qez7IjlhfhfIqHkM+4mpFJH7zjDYzsnV44G5Tne6cb2v3OL7zd0tfvfEO73+U8/7a8xEFENDGBVthNmmhlkhjCPbooc4+QTTLdEecJ2+8wHzv20cv1M4/T12c8e86wgtBL3Dm+Chsf2uBvUePAQsS5bQd2CFcAigqyVJyEKUu5CWx4X/SfYqJWvnpmola+qpioka/qtZ02vvoWazsNfPVNj+v46mc9ruOrioka+aq6AzrY+Kpmoja+qpioka8qJmrkq+quGSNf7Y/r+Kpioka+qu6aMfJVta/cyFf1OZQ2vqr2lRv5qroD2shX1dpOI1/9gsd1fFWt7TTyVXUOpZGvqrWdRr6q9pUb+aq6A9rIV9W+ciNfVUzUyFfPTNTKV9W+ciNfVedQGvmqOofSyFcVEzXyVXXXjJGvqrWdRr6q1nYa+eoXPa7jq2cmauWrioka+araV27kq4qJGvmqWttp5KtqX7mRr6p95Ua+emaiVr6q9pUb+apioka+qu6aMfJVta/cyFcVEzXy1TMTtfJVtbbTyFfV2k4jX339hXz1HS7kq+9yIV99V3UHTsVtbJExvok9oy9IpXLuX0yYz471QI8VgABKfcknM1JBrcivfLSp1pwGcAYS0BPdYs6SjmduxDFIAyzTI2RJi0OACSoIRAFWWRvZLzDlq8+H4quLdzj6hoSG5KB1CBF8SJXbSuC7iF6kVp3YxV0CBTqGMbsDRhGOEJ+uz+3cwLBTYrTfZACFCWLF0JMesSsME4T9Dsat8jrJRY4PQxe6eVTE4pDPuJq3SR+86w287d1eOGeU53u3G9r97he3+5Wv55zRy1mubgRJiNgZHo8Mh/xBdk9UwgZwxHsk/CxijBTS+BX59SCMoKh2fae1fzpFdopojC0mCXGE0DKTEKUNLS8heptl65JMMfVEe+odhDG+eQy19jJFcCRYgywoxhdRilQF8GAV0FpOlqOGJ0hSMepdLsiaKOq8AnwNLaD2kIeNJP8kS+GHzAHYTqAOIWft0mq5IEvC086bwCdHmW+EanQr8XLD1Zw5I/gK6gf0RPcX4V5yvC6fyRw8KOngx/DvUKSypYFsxTnj/fkkHCH+bOq1l3L2xsT5Z5w6VrjjSxeOZEe0YJ4aSl4cLUkavkHAJaxHmfhBzsoofnuTGsfkqK0EnGuXIhA0dwmEy9CzSSYjIpOqBpEZV5DQ+jmRHRFyEI6BY1ecUUgkSW/jb4B7xQQgMNFAmH3kBMEHby/XpeOt5M6zxiABfGAg84SxHoozIoqmFJbQCNDFRIAjU2DL+oHOxXrx2Qe+CVKSGCdgOOABj404k17XnBFdiO8AaaKrya+uOABiQRjuEB/0486/EaJnxb6g9Get5LMBRm6e/Knuu6HgxujujDIEp4euA/8ivCoyStBSjdRNeOY1w4pK2qhUDfS+eMZAltv1ndYF2tHAYLy2AEBLKKGEmmdYF+/kYFleYmG8HXCiDg/YyJjkSdRvoqM3dac16QnN5CS/4DI3wgV4dWfKSNpBTjeXK2KMQMEIblQUvABy8fZTwofijIx5JDwDJoe2iYmAHA26gGkID5IDYwKye3c8OiOWMoakIjIdupXvjWfO6KS8Qf5keFUmC9qnRB5l0V04S3AhBU0EPq5BWuBIZMzDbVFNlJKe12svoYj4V0IDeg8vwNuFKYpY2iUcLRoFk214AaRTp/V0JH8UMwNPppZaewks5dW7Iq8q7bA3HwRMAG82oseg7sCM3OYT8ULYYztwBExsej4Du/TaS5Ipuhk1yQwQHyYL2eFc6JbesowXghueALWQhEaCF+eBmCftL6qzag854DSLs3RIBxwSSHUII5dTQGhNwmVI/zqmuwx5UeYjeYLlQOvHqdZe0jjhVpjrSj9iA4kq2yL1M+wYtpP/oAT4XTm856DECzchvRQ5RYcxFzVnpP6DEICBd8HiCEd8ihStnuodlJGCbIxBeeBdUhTzwIAn8GT4a81RccYdWEsOE+cAt3aoa4b8AeZiUDIWmKbwR1CnkLR1EOAFkTuZ8zIx1fmV9Dg6mGII6UYOVoerotQXEQyVJZVoNDfiCYmMwkTf0CcQtC5zFEu81J3WtCDRJl59ouJVgb1IUqImKrlIvWvAicH0cv7zjrpumFjwIPAMO4/p1nvIAVIuBZw38Rmb3sRG8I1+x1ZLaQIs3xCFaHk0W0tUrgLhm7o8vJZUqtZeCsXGc8qFkORY5i8zY4niKzIjeWckayEvNJbiABVERiwiFUyAw15R7SHHkBa6hW/bw5un0owM2MyLbSJCCxEHHz8HhoI6UyEwko8I+oJGj6A4I5UH8GuROegk0ZD52yDnMOVH3xliY4cAoC4TObt4mAeJCIYPh69uZLX20lfULPoW8ER82+AMEE4kqlQsyfFoH+IteSNG0egCxKC99IgU78BiijPC7yDT+9iIfYQd/iUcFL92/DGEmyjT5bh6yA1Mv8rShUIWYlQfTwnPnTkjtRbwCDGFEo2TM7UinJ9iW+Ov7qQ2/EDbNpICI/qgosZATLKIQngoBQu99nI/gH+UeYfv4oo9mR7iwhho9WlHGuaQxuMzqD5lJ/OLmiv2UbgadVq19hKphELipy3KEUkGNcRqUb4jfOG8CvkWDi4dC2klBGFUsexMS3g0gkqdX0kc6OICZ+hjl+gcyxPxIo4ezGOcIfXDcBDn6TVIGXNpl+flVaCQnNpDTqFZnArwGaZCmqoS9ubT0pQDx4QzYYItAA+iDOpMHQYjylQlfHkIleaMY4d5ULOYIDhHhZGxBhwBKHYCMl5ok2tWPcD8YEwRNaBZFJ/3nUIJqEBxxpjJd4Ib9hrwnbhUIjyFR5qMEJBwj4tysqPQM6MwWeRHvDP/tsudBer8SrjtBt2iGj7l4SDFrTEtqW7sPAaVPkIzAY7ELXzFi1Pki5jb4PL6/ErGBKiCTmZcEnVkHQ+ziFQPnQ3EF9Aq4pARShghW2Ipma64AMoqZJld3XfD94NqDlInNp8ysZRgF9qJILsaIoSB5oQZysSm6oG0Toe42SlCaOWlOKPUpfxT0Y9BHp9se+Q98Iy8/iVwDqtOxQviwrBGJQK+EiiaHyxrdtSd1pILIUZNwGeS8S0qPlGUq5AxCpD02JJ8UTCkhxSpIYJyOB1zm6C91H03vI0kkZTOB4QxMIlyRIBFrE2oPwY5UBpa5SlluYliJaLw7olyVCZjUWsvgY/AX/rE7VJBot4/MfMgUFFbzAoCECyNFMyEaQLkdvH6iFXgHeNecUYMiYMioxixJ+IXqHKRCKE3TBlUNxPe4dkB75TfqKuT9IroqMa3IK/U2kuYmZDMCQcRlk9OAD90od8IKWIXEwjBisNC7OIKpS5dEniIbgY3qj3k2HpEo+DuJDvLqH26JpXSCTlCRUAGcxBICOdCuo2GPgQIRFmjBZbfDn3fzQZdJyXC6kmJdJj8HxEMkMa8kenVGVASZ6hUiJ1DxNFMAC0YqE/FGVF/Ui8ubgLNoPw8Ii+5yEZYTC91BZQrVJ3XJnUhRycKGeftl0SoSGoPeWcuk5OpPtVSmeMweB4MIp4wn7JQjEqyFJ2zEExxlqk+AR54XoOaKM5IpQjYifMOaDWH3t6lIg/cg4aMJLdBPKEqHjxL2TUDL8lGxDkcGHNK7SFPsjKGqSLPR8ENak8eZI5sgu2Z8QyotpBhSErKfUXKlwxrUT6owJQVZ1zAPOwNng5gNJHCuC/cFtkBhHcIZqSCQF3c50z1WRCW1OGo/BIzSBHqHlxUQsIiUglyyKSNCMSkhevRo1OiKThdjnUEO25ECyGfEhx3im3UzUNTay8zw54YIdaTp0tCOpFjzA+cDPmVPwD5MjtJlgNBRD02y+xBghAzSzhzRkqtUutEcfB4iJMn/EYVFRdCvYO5jgQiXmNtSI2yMsRLtuMPsixzjHrfqRRvxBRMOIpYFVAZHcZ7x01D4ym/InEncYbuZKzyM6v4ZRwKOar4Kznje5yfCz+B0WE+oLZFB7S1IVXEjRCr5DzO8AQR0MWVMUjyzVhQCuVkJDp3U3vbnSBn4jwFYz6JbMOsopaEyCd0UfrizfPWYHwboZRiYqGwzfxlpsNcR1acURyOx0lQnUcEC2PhfcvGdIIMFX9gKFaIit4hYw3yLsU0Cb9UGpAbUXFGJ8KUn+apCTnq6aQqjDBF6fV0NQr5idRPluAz6fJKrM+DgDplQdzub1nHKX3wHjfwtvd84ZxRnu89b2j3G/9f4oyO8YiCITdRDvOy+gEhShr0wAlMxiYHXm7Imn2gsIgPB3x7l0WJEZuDWlLrGZGIaZO1TR3RwKg+5PBZubyHdIq+GRNDDdMUxPhkVJhb4qqw1ZQR3Qrq/WHopuxbB9C1g/mKMkWk4uowFrIWEuEBb5NzdJG6Eu4B+WiDJw2X1HpGL+dWUBcTw0/SgdslWYTypPqZHRTeDjSNaCzKncL2n6qA235gIag0BLXHG92CPaJeukuPUvTBAPE3OwV0IiZOOMpiJ8pYifI3OXHjv3R2kIJVcepebXQvr+QA98B20AQYQBwGsLIt0geTNtIBUsTbef+kWgqhNI7sQviayQXFGRMQBYlFvkeByyrWNkTTRsnGxBG5hZ0uwzniAqKQPBBD4bkL+I8qubonB8fM9wQpzq0ui4cKAntghyWjBzHXGdgGkDsQt1LHk0LGjpwHoxHn1FmVIWMyOqiA0i2vFADSpTaNMqHE06Wse0jdzstah01oNO6KMVsiEgdsrDgj+TiKUZbiGvaN+SOLU3nxeBjkX5QjiYVb76J+KcNAF3lihhipyceoOSONgVrPikSA2FD6YnBJ6iseoICCoZaU5YJ6BH+WtfSybhYWgtjFTbozZ6ReB42UdbxbAjcjobtU8BlxpOMcl4hduAIuhrppboIRUNRUp2XZI15GcUaoO0VmBhDZHgq9kdBQqDwiJiJKYXcTIZihREEW85ADqMJOrCqsi2qkOquSt0g+oaQfvawB2gVYUc3i94LsRNgGFclNcgx+rVAwJGmh5EQeyaYFxRklV6FYYDXkrA1V7Sb5ElaDRogUGxEgKNAoiyXh24EKJG5I1urSB3hGxRkpPtMs8FUGbdE+oFKnj4DjW0F6gT6jl4I3UwZ500i9Ik9kMRYEkSfWe7wHQ5GeyQfYv0hdDRNLR2CBsIUhQTzQoK7xTahTavyIVlmSCeVjQg3FGZ92RGC7CUUUkwu6lLIDoiHuXoqydBpAqaKrZa5Cpr0U6ykSyJrCpTkj/g5f755IGe6my8oH0b0CfjLEcxBjqaUIqMEcdCnEoj+rrCgNspJW7fEOogTQ5YAxBlmVNeAUIBjcWYqVB9MiCRVFPotnkxKrAEJcFjMY2ag44y42GBsAYaE2wkRzG5QgAgEZ9zimTdajZBkf9B7xF/gaxOVSl8WXhx+mxn2nroCMykMIkiy4FYfSPa8GVxGAgkyyXRwiohkXxTOBQqhPOBk46qzKIFpSlpCIGVwgYCrVXk5njoHUgVHGGcrqemA+vOogYuCeOj6QELYjPNUeb3QadkB20xCoCYjUk2BL5LPmATdyKyO8kRrtk/GpAvKRSk10/pRz0dV6RlgBdWSk4iQ8Qfopp+NxcBQkMVIKmRPBvAtAgY2g1r1kUJA4DITHSpozTsAo002mnPDnjDmpQZgLPqzxAE1WCmFzE3OsdHleqfXIStEME1F7vIFhomBpFrCbHEYBykm6kuW3qFEZt4Lv5AwlMZIMLUor+MuGzSViqLMqicEdeEIi4E3w4kiWchIULhruTLken0mMDxh8JgBWEd2bn6YC1R1expkzBhnQQk54KbKlCGMWsW9ooBX5rEnHytoqIinDAneEVO5igSCJhBSf1b3ai7SwiXcWuSH1OBAJ6aJ4qmeM8wloZ6YP6qMM/8WIo8yZWhQWwItTnNFhVAV2+ichAE7EpXc5NYrqKa5HCgGCcsEhUHbMLXWDIWWjzGCDzmxqPSOJ9ZCtXWSvIFp9gHul1MHcpXLJ1MZGh4wfxtEOSpxU/WTXFaGaPJN3xRmpxkbZVraClOywFrJ+jlxLcpPDtLC2iQcqzA3MuyQFJxtb6CK5aqAHtcebCC9nbTHvRYFNkmwVnzplmwWscUDIKDYRQfgeSKsnYj8tbYe0D5y9vlcbHCbTAj/ZKXHKUqcMesyytmkTRiBLNqjFSqmJXNAGGJs4DnASD6Pv1XZS+GBEbThsee/0FjKkUHJcQueZLoSMXdZAIC+Rwb6hOKH3AUoHI1ecEWvJC5NKBtXsA9UE9wePS32FvwjmlmVrIAb0CoFR9lFsckMDFp4hWJfa401teopAC0mUN8wGkItzxAweBBUcHbKU8N5kU40IFKFl4EhGl5Qr3Jkzgn+f6sFIkLBQ9FQWpcaJ/kLswPH4MYxTxgIaWmqyIph2YWKoPcB7UpyRl0VcEHIYJLKSziKjACZZgf/EY9gFr0CujWD+URpfEZPbmLo4fj7tj6rnwncC9A6ZyhRoGMr4Yn5XhCGJBpxDHqpCpxrBlNFI5EDhBVmzCr9Te7xLksVXonQAQDXJVgm0mJPlOrSC1yULBofUcehhOpE36Z7WykKFU01qPeMALzPr3pxKQd6yUJe6G1riIF9Qi2GuUCeNUgSX5YlSTiW9kAHAQHVT6xnhkNiKrchtu3Jdbg6yFg8UilBjBC/wK9X7J75BiKOMj+pGvDP6M+GjqbMqo4RQFDlkBXpKcuCHOok/KElZVVQgCZJZloxBvEuXhb2TGuKU7KE4I4Og4B8GkrALFkhSqSGJyJpWMghEbaMkl3OSEU0lSVZF0Rci8iLvQq9n9II+iwx7dH0fUqwjYFJ8A6nyH+YdGZUAUwmxAHpZW4qkI4eSbGCXijMyLfgYiBI0g9mNDJC7gwefLO4tU20MRIUlC8gLCQvehPDi7zwtix5Br2fEM2IVpHZG3ZGaDM8jq61p9CY7QJLsxWNOUZJIWZa38/IOvp9yRaSxaj1jIpcR4AKAiMrkEEzNhNm3kJpsUZXVLoOaqGQfwhp5tsvgxhK6DDSZijN6PoC4jCMFBFGIIx1W2awk4nwTvtUlqw7RIw1uHGT9i5gjQhwucleckWbTeB58MWn5U1L3kKUTO5XPSm7sADWgIEEfzIgolKXiMt2ppfFm1b3aUpXkuwrhowNrpsuyHxEUjnYD/oKmMVtASmItlIofwatPvCcYJgYg6T3esiqAjNielt1irxiswW/Yl/G0RlDcGXNiiIERdQaDmMJ9ZflBPLZdcUYpeuPNCJhSsvFRisfkzAhepci3waAO3IwT1ieav2E8CLdSLya8OLXHG3ouAR1nT1cDDwmf9L8IkECIFY1EdGZSM70cPcu8/MqFIBPNsPWg1jMS+ijGDtGW8FeGPGZ9ZVmJsjvZP0cXUslk6CXqcvgNXsEmO/CQFwSKciVnfK8zg+M5CCeyV0AkpdTimd6iKgv4ExlOGNtkMXDapU7+tECL6rdU28gfMav1jEF2iyOXi6xKpeJKrRSyKMs9xWrLOhdoLb4tyIZQCF+VHZLMKV4XHiepMzQpPj9NFf+0TAu3yA+Lc+RYBQ0iLwgY7qkAVykg4hzhHnPJEnow7fCfoc8WBPELMoDFy24pxtaiTbImQBYqMRepmuJYCGFihvhg8l+cgpOIL1U+42reJn3wXjfwtvd+4ZxRnu+9b2j3+9zcbut6ZFm7+u43tPsPv+7mdsteaTA8pbsqVX1Zd09jRWcRH2QNh99kIsNxqObIinsENIaZIkBFGzzVNN54Q7u/6OZ2o5pkIRF6nJo/Aky2ouBAhvANtONEQGBqqFZTew6yGKbK/tVeSK24uzxlbr/PDe3+4ovb/crX6y5+zve9bj76C8e4v3Dc+HNfoE6QiBnLQ8ZrsmE1yzbfJdKfgQIAKlEWRmHRvVTXZbUwYgLZKXtn3P7WxqCzfXnpg/e9YQy+3wvPMfJ873dDu9//Na+OufcBr1H8Nsv2wM3BSuVYZdA4Vo1CBtVlfIVs8tj5X4YotiGyTnbx7fKbcJAS1dyTHeFZTviRXeddHBA6bqGiNi9oR/ZJYjKfWCflNYx9kXXnqGSYLGD0PPcwCFhs6BCqFzfJt4LSwQGy4CIWXxHB2BrZgg8phgFV/CSc45iE233bkoqDADN+DhAnNH5cl11MUFMv1JXimGykrHIWUka0N0hpkO2oh2BLQre/ZwxKH3zADWPwA1/43JPn+8Ab2v1Br5K598HKW1F/EP+EeaFcssuyyST7i+UMgu0ANMC8ZKXWvssmkYB8DHAO2S0jh/LouScLMeCIUCMYFWlkSNUEwOflPtUN9CuCBActuBNS3aPs1t1liXpokOnz3MPhUMtz0AFwGj8RDnDINIFbUlSBnVFlCKStITXvXbZ6z1rzQvXJ9vkQVN7LIADoF0TUUV4M7QBgzlkOWRwpG01laSklmsWroByQ+1jYeWGjCdoSbhmD0gcffMMY/JAXPvfk+T7khnZ/6Av3VqJx3v+Gdn/JC/dWkl8+6IZ2f+kL91Yytz/0hnb/kVeJt/qwC73VhWPcXzhuvOqLoz2dNwHok7oCRU05zOYJDpJdZTce1csqazHSkD2NTKo6kbQVmkkR+JZYK33wYTeMwQ9/4TlGnu/Db2j3R7xK9N1HXuitvuRCb/WlF3qr89zzVfYoUmx1XTZCRUqwPVA2ombztPB6RpLYWHuSujlt3BMEJMm2kZ5k9+0dY1D64CNvGIMf9cLnnjzfR93Q7o9+lcy9j7nQW33Jhd7qSy/0VmruwTOmHDhWthKTlFsp4++8xSkrOIAahywWrJ6ERwmx7GN5qb/JHqSWqe/eMQalDz7mhjH4sS987snzfewN7f64F+6tRON8xA3t/rIX7q0kv3z0De3+8hfurWRuf9wN7f6KV4m3+vgLvdWFY9xfOG686otjuXYU8tXaKvN+hZZkKRYBofLevJy7K+eoHH3OENvT+jwylQSRKDsZ39oYdLYvL33w8TeMwU944TlGnu8Tbmj3J75K9N0nXeitvuxCb/XlF3qr89wLXjZ3UyHuo0zyrhO1yA8MTs5B3laYLT2diVUXWYqPkPM/WpGN8BXBG+4Yg9IHn3TDGPzkFz735Pk++YZ2f8qrZO65C73Vl13orb78Qm91nntMqwQtrAglN3mcrcl5TXJittzw7btsG+xB1ijHIUdiH7SVHyTHA4Tk8y15T/rA3TAG/Qufe/J8/oZ2h4vb/dpnz+cPaPMR5SA1NHd2Ti5HqozBtDVif6+xpCzHCQxZfSqboVzeZ2xjS7JJLIvGOedmL4dHjCo3XJR5kP3QYWGUjdbLRQauJn84fJns9pBjQzIzpTsoOL88RniK3SrebDPWMMOkSFsbKTRE3tqscrKxHPQVfXjaFs0DPh3ELAvns2fG+1H3UTcZi+E11/f321z3WfKIXxUL3+bxP75e81Z+/TbPfv8dv/Kf3+VbPH7kVn7MN3r+/W//7J/vdfrz1174Pl75/Dfe8/nu7R5v+fVep1+/8Vk7z+/xq1/0DK983itz6G0fb/n1Ns/+7JXvfcOz53vN9c/nnz/La9/Kz3rl6z2/8p9vPP3eK+/z/wZRalXhC3wDAA==","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"61":{"source":"// This circuit takes a move and a salt, and returns their Pedersen hash commitment.\n// It's intended to be called via `nargo execute` by the backend.\nfn main(move: u8, salt: Field) -> pub Field {\n    // Ensure the move is valid (0 for Rock, 1 for Paper, 2 for Scissors)\n    assert((move == 0) | (move == 1) | (move == 2), \"Invalid move provided for commitment generation\");\n\n    // Compute the Poseidon hash\n    let commitment = std::hash::poseidon::bn254::hash_2([salt, move as Field]);\n    commitment\n}","path":"/home/eya/zkp-rps-game/noir_circuits/commitment_helper/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert"]}